

### Java笔记

### Part One 易错点提示

1. 常量优化机制：在编译时，整数常量的计算会直接算出结果，并会自动判断该结果是否在byte取值范围内；若在，编译通过；若不在，编译失败； 

   `byte c = 3 + 4` //编译通过 

2. `'a' -->97; 'A' --> 65; '0' -->48; 0-9` 是连续的； 

3. 计算机中的数据，是以二进制补码的形式在运算； 

4. 位运算 

   `&`  遇0则0 	`|` 遇1则1 	`^` 同为false,异为true 	`~`  取反，包括符号位 

   `<<` 有符号左移，符号为丢弃，右边补0(每移一位，相当于除2） 

   `<<` 有符号右移，根据符号为补齐左边 (每移一位，相当于除2） 

   `>>>  `无符号右移，左边补零 

5. 循环语句 --> log: 其他语句  break log; (退出log部分的语句)

6. 内存分配： 

   > 1. 栈内存（方法运行时，会先进栈）， 存储每个Java方法的局部变量表等，各种基本数据类型，对象引用，方法执行完会自动释放
   >
   > 2. 堆内存：存储对象（包括数组对象），new出来的对象都在堆内
   > 3. 本地方法栈：当程序调用native的本地方法时，本地方法执行的内存区域
   >
   > 4. 方法区（存储class文件)：被JVM加载的类信息、常量、静态变量等
   >
   > 5. 寄存器(给CPU使用） ：包含每一个线程下一条要执行指令的地址

7. 方法重写：两小两同一大 

   > 两小：子类 抛出的异常小于等于父类 ；返回值类型小于父类 
   >
   > 两同：方法名相同，形参列表相同 
   >
   > 一大: 访问权限大于等于父类（public,private) 

8. 方法重载：不能通过返回值类型判断是否是重载，重载与返回值无关 

9. 方法传值： 

   * 基本数据类型：传入的是值，形参变化，实参不变 

   + 引用数据类型：传入的是内存地址（使得形参，实参指向同一个内存），形参改变，实参也会变 

10. 多态成员访问： 

    1. 成员变量： 编译看父类，运行看父类 

    2. 成员方法： 编译看父类，运行看子类 

       ```java  
       Fu f=new Zi(); 
       System.*out*.println(f.num); //输出父类Fu的 num 
       f.method(); //执行子类的method()方法 
       ```

    * 多态好处：提高程序的扩展性； 弊端：子类的成员变量使用受限制 

11. 关键字 `instanceof`  ===> `变量名` `instanceof` `类型 ` `true /false` 

12. 成员变量没有多态说法,编译是父类,则运行时也是父类变量,编译时是子类,则运行时也是子类变量

13. 抽象类

    1. 抽象类不能创建对象
    2. 抽象类可以有构造方法,供子类创建对象时,初始化父类使用

14. static 关键字： 

    1. 可修饰成员变量，成员方法，类 

    2. 随类的加载而加载，优先于对象存在 

    3. 可通过类名调用，也可通过对象名调用 

    4. 静态方法不能出现this、super关键字 ，且不能被子类重写

    5. 可以使用静态导入 import static java.lang.Math.*;

       Math.PI ==PI (静态导入后可简写)

15. super关键字 

    1. 每个子类的构造方法第一条都是super(),都会调用父类无参构造 
    2. 若父类没有无参构造器： 
       + 子类通过super(……)显式地调用父类带参构造器 

       + 子类通过this关键字调用自身其他构造器，在其他构造器中调用父类构造器 

       + this() ，super()必须在构造方法的第一行，且不能共存 

16. final关键字 

    1. 可修饰成员方法，成员变量，类 
    2. 修饰类：不可被继承但可以有父类 
    3. 修饰方法：不能被重写 
    4. 修饰变量：表示是常量，不能被再次改变 
       * 变量是基本类型，不能改变的是值 

       - 变量是引用类型：不能改变的是地址，但地址里存的内容可以被改变（如：set()方法） 

17. 代码块 

    1. 局部代码块 ==>方法中定义（方法体） 

       + 限定变量的生命周期，提高内存利用率 
    2. 构造代码块==>类中方法外定义 
       + 每次执行构造方法时都执行，且在**构造方法执行前执行** 

       + 作用：多个构造方法中相同的代码可放入构造代码块中 
    3. 静态代码块==>static 修饰的代码块 
       - 随类的加载而执行 

       - 在类加载时做一些初始化操作 

18. 接口 

    1. 成员变量：public static final 

    2. 成员方法：public abstract 

    3. 没有构造方法 

    4. 默认方法（jdk8): public default 返回值类型 方法名( 参数列表) {} -->解决接口升级的问题 

       1. 例子：public default void show1() { ……} 

       2. 不是抽象方法，被实现时不强制重写，重写时去掉 default 关键字 

       3. public可省略，default 不可省略 

       4. 实现多接口时且存在相同默认方法时，必须重写 

    5. 静态方法（jdk8): public static 返回值类型 方法名（参数列表）{} 

       1. 例子：public static void show2() { …… } 

       2. 只能通过接口名调用，其实现类以及对象无法调用 

       3. public 可省略，static 不可省略  如：static void show3();

    6. 私有方法（jdk9）：private 返回值类型 方法名（参数列表） {……} 

       1. private void show3() {……} 

       2. private static void show4() {……} 

          注意：

       3. 默认方法可以调用私有静态方法和非静态方法 

       4. 静态方法只能调用私有静态方法 

19. 比较接口

    > Comparable
    >
    > - 实现 int compareTo(Object obj) 方法
    >
    > - this.compareTo(obj)
    >   - this>obj:返回正整数	this=obj:返回0	this<obj:返回负整数 

    > Comparator
    >
    > - 实现 int compare(Object o1,Object o2) 方法
    >
    > + o1>o2:返回正整数	o1=o2:返回0	o1<o2:返回负整数

20. 枚举（public static final 必须要求修饰变量)

    1. jdk1.8后，缺省/public enum 枚举类名{}

    2. enum默认有私有空参构造(private修饰)，可自己加有参构造和属性(只能private修饰)

    3. 举例：

       ```java
       public enum Week{
       	MONDay("星期一"),TUESDAY("星期二");
           private final String description;
           private Week(String desc){
               this.description = desc
           }
       }
       ```

    4. 常用方法

       toString()	String name()	int ordinal()	Enum[] values()	Enum valueof(String name)

21. 包装类

    1.  Integer.MAX_VALUE 和 Integer.MIN_VALUE	Long.MAX_VALUE 和 Long.MIN_VALUE	Double.MAX_VALUE 和 Double.MIN_VALUE

    2.  整数转进制:Integer.toBinaryString(int i)   toHexString(int i)

    3.  方法区中常量池的缓存对象

       ![image-20220323114959258](http://ybll.vip/md-imgs/202203291308832.png)

       ```java
       Integer a = 1;
       Integer b = 1;
       System.out.println(a == b);//true
       
       Integer i = 128;
       Integer j = 128;
       System.out.println(i == j);//false
       
       Integer m = new Integer(1);//新new的在堆中
       Integer n = 1;//这个用的是缓冲的常量对象，在方法区
       System.out.println(m == n);//false
       
       Integer x = new Integer(1);//新new的在堆中
       Integer y = new Integer(1);//另一个新new的在堆中
       System.out.println(x == y);//false
       
       Double d1 = 1.0;
       Double d2 = 1.0;
       System.out.println(d1==d2);//false 比较地址，没有缓存对象，每一个都是新new的
       ```

       

22. 内部类 

    1. 访问特点： 

       > 1. 内部类可直接访问外部类成员（包括私有) 
       > 2. 外部类访问内部类时，必须先创建对象

    2. 成员内部类： 和成员变量一个位置 
       > 1. 外界如何创建：Outer.Inner cls = new Outer().new Inter(); 
       >
       > 2. 静态成员内部类： Outer.Inner cls = new Outer.Inner(); 
       >
       >    - 一般方法：cls.show1(); 
       >
       >    - 静态方法：Outer.Inner.method(); 

    3. 局部内部类（理解）：方法中定义的类，外部无法直接使用 

    4. 匿名内部类（应用）：本质===> 是一个继承（或实现）了该类（或接口）的子类匿名对象 

23. Lambda表达式 

    1. 体验：`接口名` `对象名`  `=` `goSwimming(()->{System.out.println("老铁，我们游泳吧!")}); `

    2. 三大要素：形式参数，箭头，代码块 

    3. 使用前提：有一个接口，接口中有且只有一个抽象方法 

    4. 省略模式： 
       - 参数类型可以省略，有多个参数必须都省略，不能只省略一个 
    - 参数只有一个，小括号可以省略 
       - 代码(方法体)只有一条,可以省略大括号和分号,若是return,也需要省略 

       ```java
       Comparator<Integer> com1 = new Comparator<Integer>() {
                   @Override
                   public int compare(Integer o1, Integer o2) {
                       return Integer.compare(o1,o2);
                   }
               };
       
               int compare1 = com1.compare(12,21);
               System.out.println(compare1);
       
               System.out.println("***********************");
               //Lambda表达式的写法
               Comparator<Integer> com2 = (o1,o2) -> Integer.compare(o1,o2);
       
               int compare2 = com2.compare(32,21);
               System.out.println(compare2);
       
       
               System.out.println("***********************");
               //方法引用
               Comparator<Integer> com3 = Integer :: compare;
       
               int compare3 = com3.compare(32,21);
               System.out.println(compare3);
       ```
       
       

24. Lambda表达式和匿名内部类区别： 

    1. 匿名内部类可以是接口，抽象类以及具体类；Lambda表达式只能是接口 
    2. 接口中只有一个抽象方法时才可用Lambda表达式，有多个时二者中只能使用匿名类 
    3. 实现原理不同 
       - 匿名类：编译后，产生单独的.class字节码文件 

       - Lambda表达式：编译后不产生.class文件，而在运行时动态生成 

25. 注解

    > 【元注解】
    > 【修饰符】 @interface 注解名{
    >     【成员列表】
    >
    > }

    	> 四个元注解
    	>
    	> `@Retention`:声明周期
    	>
    	> `@Target`:使用位置
    	>
    	> `@Inherited`:是否能被继承
    	>
    	> `@Documented`:是否被生成到API文档	

    > 成员列表只能是：
    >
    > - 八种基本数据类型
    > - String类型 Class类型 enum类型 Annotation类型
    > - 上述类型的数组

26. 常用API 

    1. System（应用） 
       1.  public static void exit(int status) -->终止当前运行的java虚拟机，非0表示异常终止 
       2.  public static long currentTimeMillis() -->返回当前时间（ms) 
    2. Object 
       1. toString() 
       2. equals():比较两个对象的地址 
          1. 若不想比较地址，而是针对属性比较时，可重写 
          2. 重写equals() 和 hashCode()方法 
    3. Objects（应用） 
       1. toString(对象)  
       2. toString(对象,默认字符串) 
       3. isNull(对象) 
       4. nonNull(对象) 
    4. BigDecimal（应用）-->精确计算 
       1.  add() 加法 
       2.  subtract() -->减法 
       3.  multiply() -->乘法 
       4.  divide() -->除法 
       5.  divide(BigDecimal对象，精确位置，舍入模式) -->除法 
    5. Arrays（应用） 
       1.  String toString(int[] a) -->返回数组内容的字符串表示形式 
       2.  void sort(int[] a) -->排序 
       3.  int binarySearch(int[] a,int key) -->二分查找返回指定元素的索引 
    6. Date（应用） 
       1. 构造方法：Date() Date(long date) 
       2. getTime() -->从1970年1月1日00.00.00到目前的毫秒值 
       3.  setTime() -->设置时间 
    7. SimpleDateFormat（应用）--> 用于以区域设置敏感的方式格式和解析日期 
       1. 构造方法 
          1. SdimpleDateFormat() 使用默认模式和日期格式 
          2. SimpleDateFormat(String pattern) :使用给定的模式和日期格式 
       2. 常用方法 
          1.  public final String format(Date date) 将日期/时间格式化成字符串 
          2.  public Date parse(String source) 从给定字符串开始解析生成日期对象 
    8. JDK8新增时间日期类 
       1. LocalDate -->表示日期 
       2. LocalTime -->表示时间 
       3. LocalDateTime -->表示时间加日期 
          1.  public static LocalDateTime now() -->获取当前系统时间 例子：2021-04-26T21:57:54.152 
          2.  public static LocalDateTime of(年,月,日,时,分,秒）-->参数为int类型 
             1. LocalDateTimeldt2=LocalDateTime.*of*(2021,4,26,21,58); 
             2. 2021-04-26T21:58 
          3.  public int getYear() 
          4.  public int getMonthValue() 
          5.  public int getDayOfMonth() 
          6.  public int getDayOfYear() 
          7.  public int getMinute() 
          8.  public int getHour() 
          9.  public DayOfWeek getDayOfEWeek() 
       4. Period（应用） 
          1.  public static Period between(开始时间,结束时间) -->获取对象,参数为LocalDate 
          2.  public int getYears() , getMonths() ,getDays() 
          3.  public long toTotalMonths() 
       5. Duration（应用） 
          1.  public static Durationbetween(开始时间，结束时间) -->计算时间间隔；参数为：LocalDateTime对象 
          2.  public long toSecconds() 
          3.  public int toMillis() -->获取时间间隔的毫秒; int toNanos()-->获取时间间隔的纳米 
    9. Optional 

27. switch支持 byte,short,int,char 不支持long,jkd1.5后支持枚举,jdk1.7后支持String

     

28. 异常 

    1. Throwable 
       1. Error 
       2. Exception 
          1. RuntimeException（非受检异常） 
          2. 其他所有异常，包括自定义 （受检异常）-->编译期需处理 
    2. 自定义异常类 
       1. 继承自带异常类 
       2. 提供空参和有参构造器 

29. 集合 

 

### Part Two 笔记总结

##### 1. Java基础

###### 	JavaSE概述

1. 机器语言的发展 ：

   机器语言-汇编语言-高级语言

2. 计算机语言分类![](http://ybll.vip/md-imgs/202203291308521.png)

4. Java语言跨平台原理

   Java设计了一套简洁的虚拟指令集，也就是字节码。如果我们想要在一台机器上运行Java程序，只需要将Java程序编译成字节码就可以了。

   Java虚拟机（JVM,Java Virtual Machine）：由软件技术模拟出计算机运行的一个虚拟的计算机，它负责解释执行字节码指令集，一台机器可以运行Java的虚拟机，它就能运行Java程序（一次编译，处处运行）；而不同的平台（Windows、Linux等），需要安装不同的Java虚拟机程序![](http://ybll.vip/md-imgs/202203291308589.png)

   Java虚拟机不仅解决了Java程序跨平台的问题，也解决了很多语言跨平台问题![](http://ybll.vip/md-imgs/202203291308875.png)

5. JVM、JRE、JDK的关系

   `JVM`：`Java虚拟机`，运行所有Java程序的假想计算机，是Java程序的运行环境之一，也是Java最具吸引人的特性之一

   `JRE`：`Java RunTime Environment`,Java程序的运行时环境；包含JVM和运行时的核心类库

   `JDK`：`Java Development's Kit`,Java程序开发工具包；包含JRE和开发人员使用的工具

6. Java程序开发的三步骤：编写 编译 运行

   .java -->编译 (javac xx.java) --> 字节码文件 .class --> 运行 (java xx(类名)）

7. 关键字：Java已经定义好的单词，有特殊含义，50个，其中const / goto是保留字(未使用的关键字) ; ture/false/null 较特殊，可以不看作关键字

8. 标识符：26字母大小写，0-9的数字、下划线_、美元符号$构成，不能以数字开头，不包含空格，不使用关键字，严格区分大小写

9. java数据类型

   ![](http://ybll.vip/md-imgs/202203291308028.png)

10. 基本数据类型

    10(int,默认整型)	10L(long)	10.1(double,默认double)	10.1f(float)  

    十进制：10   二进制：0b/0B开头 0b10	八进制：0开头 010	十六进制：0x/0X 0X10 ![](http://ybll.vip/md-imgs/202203291309314.jpeg)

11. 一个字符占几个字节？

    JVM内存中，一个字符占2字节，文件保存或传输时，不同编码占用字节不同，ISO8859-1(1Byte)	GBK(1或2Byte)	UTF-8(1-4Byte)

12. 运算符

    &(按位与)	|(按位或)	~(按位非)	^(按位异或,相同为0不同为1)	<<n(左移n位，扩大2^n倍)	>>n(右移n位，缩小2^n倍)	>>>(无符号右移)

    优先级：
    
    ![image-20220325115555420](http://ybll.vip/md-imgs/202203291309828.png)



######  数组

1.初始化：

```Java
//动态初始化
int[] arr = new int[5];
for (int i = 0; i < arr.length; i++) {
    arr[i] = i;
}
//静态初始化：用静态数据(编译时已知)为数组初始化，length由静态数据个数决定
int[] arr = {1,2,3,4,5} //正确
int[] arr = new int[]{1,2,3,4,5} //正确

int[] err; 
err = {1,2,3,4,5} //错误
err = new int[]{1,2,3,4,5}//正确
```

2.数组元素的初始值

![](http://ybll.vip/md-imgs/202203291309642.png)

3.内存分析

```java
public static void main(String[] args) {
  	int[] arr = new int[3];
  	System.out.println(arr);//[I@5f150435
}

```

![](http://ybll.vip/md-imgs/202203291309243.jpeg)

> 思考：打印arr为什么是[I@5f150435，它是数组的地址吗？
>
> ​	答：它不是数组的地址。
>
> 问？不是说arr中存储的是数组对象的首地址吗？
>
> ​	答：arr中存储的是数组的首地址，但是因为数组是引用数据类型，打印arr时，会自动调用arr数组对象的toString()方法，该方法默认实现的是对象类型名@该对象的hashCode()值的十六进制值。
>
> 问？对象的hashCode值是否就是对象内存地址？
>
> ​	答：不一定，因为这个和不同品牌的JVM产品的具体实现有关。例如：Oracle的OpenJDK中给出了5种实现，其中有一种是直接返回对象的内存地址，但是OpenJDK默认没有选择这种方式。

4.数组的常见算法

```Java
//冒泡排序
public static void bubbleSort(int[] arr) {
	if (arr == null || arr.length < 2) {
		return;
	}
	//从后往前遍历，每次循环均找到最大值/最小值，放在arr[e]的位置
	for (int e = arr.length - 1; e > 0; e--) {
		//0-e遍历，逐个比较大小，使得最大值/最小值能在最后一个arr[e]
		for (int i = 0; i < e; i++) {
			if (arr[i] > arr[i + 1]) {
				swap(arr, i, i + 1);
			}
		}
	}
}

/**
  * 选择排序 O(N^2)
  * @param arr
*/
public static void selectionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    //从i=0开始，遍历到最后第二个，二层循环中，往后找到最大值/最小值的位置，再与i位置进行交换。
    for (int i = 0; i < arr.length - 1; i++) {
        int minIndex = i;
        //每次从i+1遍历到最后，找到最大值/最小值的位置。
        for (int j = i + 1; j < arr.length; j++) {
            minIndex = arr[j] < arr[minIndex] ? j : minIndex;
        }
        swap(arr, i, minIndex);
    }
}

/**
	 * 插入排序 O(N) - O(N^2)
	 * @param arr
	 */
public static void insertionSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    //从arr[1]开始，往后遍历所有
    for (int i = 1; i < arr.length; i++) {
        //每次将arr[i]当前位置的数,进行比较，逐未交换，插入到 i 位置前的合适位置，确保arr的 0 - i 位置有序
        for (int j=i - 1; j >= 0 && arr[j] > arr[j + 1]; j--) {
            swap(arr, j, j + 1);
        }
    }
}

//快速排序
public static void quickSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    quickSort(arr, 0, arr.length - 1);
}

public static void quickSort(int[] arr, int l, int r) {
    if (l < r) {
        swap(arr, l + (int) (Math.random() * (r - l + 1)), r);
        int[] p = partition(arr, l, r);
        quickSort(arr, l, p[0] - 1);
        quickSort(arr, p[1] + 1, r);
    }
}

public static int[] partition(int[] arr, int l, int r) {
    int less = l - 1;
    int more = r;
    while (l < more) {
        if (arr[l] < arr[r]) {
            swap(arr, ++less, l++);
        } else if (arr[l] > arr[r]) {
            swap(arr, --more, l);
        } else {
            l++;
        }
    }
    swap(arr, more, r);
    return new int[] { less + 1, more };
}

//归并排序
public static void mergeSort(int[] arr) {
    if (arr == null || arr.length < 2) {
        return;
    }
    mergeSort(arr, 0, arr.length - 1);
}

public static void mergeSort(int[] arr, int l, int r) {
    if (l == r) {
        return;
    }
    int mid = l + ((r - l) >> 1); //等价于 l + (r-l) / 2 ; （l+r) / 2 可能越界
    mergeSort(arr, l, mid);
    mergeSort(arr, mid + 1, r);
    merge(arr, l, mid, r);
}
//合并左右有序数组
public static void merge(int[] arr, int l, int m, int r) {
    int[] help = new int[r - l + 1];
    int i = 0;
    int p1 = l;
    int p2 = m + 1;
    while (p1 <= m && p2 <= r) {
        help[i++] = arr[p1] < arr[p2] ? arr[p1++] : arr[p2++];
    }
    while (p1 <= m) {
        help[i++] = arr[p1++];
    }
    while (p2 <= r) {
        help[i++] = arr[p2++];
    }
    for (i = 0; i < help.length; i++) {
        arr[l + i] = help[i];
    }
}
```

######  面向对象

> 面向过程的程序设计思想：POP,关注的焦点是过程，过程就是操作数据的步骤，如果过程的代码实现重复出现，这可以抽象为一个函数，以函数为组织单位。
>
> 面向对象的程序设计思想：OOP,关注的焦点是类，在程序设计过程中，参照现实中的事务，将事务的属性特征、行为特征抽象出来，用类表示。

1. 对象内存分析

   > 对象保存内存中时，由3部分组成
   >
   > - 对象头
   >
   >   - Mark Word:记录了和当前对象有关的GC、锁等信息；
   >
   >   - 指向类的指针：记录数据存储在方法区的首地址；
   >
   >   - 数组长度（数组对象才有）
   >
   > - 实例数据
   >
   > - 对齐填充：Java对象占的内存必须是8bit的倍数

3. 静态和非静态的区别

   - 静态的变量和方法，可以在本类的任意方法、代码块、构造器直接使用

   - 非静态的变量和方法，只能在本类的非静态的方法、代码块、构造器中使用

4. 封装

> 权限修饰符：public,protected,缺省,private

| 修饰符    | 本类 | 本包 | 其他包子类 | 其他包非子类 |
| --------- | ---- | ---- | ---------- | ------------ |
| private   | √    | ×    | ×          | ×            |
| 缺省      | √    | √    | ×          | ×            |
| protected | √    | √    | √          | ×            |
| public    | √    | √    | √          | √            |

外部类：public和缺省

成员变量、成员方法、构造器、成员内部类：public,protected,缺省,private



######  异常

- Throwable:所有Java语言中的所有错误或异常的超类

  - > 两个方法：
    >
    > `public void printStackTrace()`:打印异常的详细信息
    >
    > `public String getMessage()`:获取发生异常的原因

  - ![1562771528807](http://ybll.vip/md-imgs/202203291310501.png)

- 异常的处理,五个关键字：`try` `catch` `finally` `throw` `throws`

  ***

  - `try...catch...finally`

    ```java
    try {
        int result = a/b;
        System.out.println("result = " + result);
    } catch (NumberFormatException | ArrayIndexOutOfBoundsException e) {
        System.out.println("数字格式不正确，请输入两个整数");
    }catch (ArithmeticException e){
        System.out.println("第二个整数不能为0");
    }finally{ //finally不能单独使用
        //除非调用退出JVM的方法，如`System.exit(0)`等时finally不会执行，否则finally一定执行
        //try catch中就算有return,finally代码块也会执行
        ...
    }
    ```

  ***

  - `throws抛出异常`

    > ***编译时异常：***如果在编写方法体的代码时，某句代码可能发生**编译时异常**，不处理编译不通过，但是在当前方法体中可能不适合处理或无法给出合理的处理方式，就可以通过throws在方法签名中声明该方法可能会发生xx异常，需要调用者处理

    > ***运行时异常：***当然，throws后面也可以写运行时异常类型，只是运行时异常类型，写或不写对于编译器和程序执行来说都没有任何区别。如果写了，唯一的区别就是调用者调用该方法后，使用try...catch结构时，IDEA可以获得更多的信息，需要添加什么catch分支。

    > 方法重写时，对throws的要求：
    >
    > - 如果父类被重写方法的方法签名后面没有 “throws  编译时异常类型”，那么重写方法时，方法签名后面也不能出现“throws  编译时异常类型”。
    > - 如果父类被重写方法的方法签名后面有 “throws  编译时异常类型”，那么重写方法时，throws的编译时异常类型必须<=被重写方法throws的编译时异常类型。
    > - 方法重写，对于“throws 运行时异常类型”没有要求。

  ***

  - `异常throw`

    > `throw语句`抛出的异常对象，和JVM自动创建和抛出的异常对象一样。
    >
    > - 如果是编译时异常类型的对象，同样需要使用throws或者try...catch处理，否则编译不通过。
    > - 如果是运行时异常类型的对象，编译器不提示。
    > - 但是无论是编译时异常类型的对象，还是运行时异常类型的对象，如果没有被try..catch合理的处理，都会导致程序崩溃。
    >
    > throw语句会导致程序执行流程被改变，throw语句是明确抛出一个异常对象，因此它下面的代码将不会执行，如果当前方法没有 `try...catch` 处理这个异常对象，throw语句就会代替 `return语句` 提前终止当前方法的执行，并返回一个异常对象给调用者。

***

+ 自定义异常

  + 如何定义

    > 1. 自定义一个编译时异常类型：自定义类 并继承`java.lang.Exception`。
    > 2. 自定义一个运行时异常类型：自定义类 并继承`java.lang.RuntimeException`。
    >
    > **注意：**自定义异常只能通过 `throw` 抛出

  - **步骤**

    >  * 如何自定义异常类？
    >
    >    1. 继承于现的异常结构：RuntimeException 、Exception
    >
    >    2. 提供全局常量：serialVersionUID
    >
    >    3. 提供重载的构造器

  + 代码演示：

    ```java
    public class MyException extends Exception{
    	static final long serialVersionUID = -7034897193246939L;
    	public MyException(){
    	}
    	public MyException(String msg){
    		super(msg);
    	}
    }
    ```


##### 2. 多线程

> 1. 分时调度：所有线程轮流使用CPU的使用权，平均分配每个线程占用CPU的时间
> 2. 抢占式调度：优先让优先级高的线程使用CPU，如果优先级相同，则随机选用线程调度（Java为抢占式调度）

***

###### 1. 如何实现多线程

1. 继承Thread类

```java
public class MyThread extends Thread {
    //定义指定线程名称的构造方法
    public MyThread(String name) {
        //调用父类的String参数的构造方法，指定线程的名称
        super(name);
    }
    /**
     * 重写run方法，完成该线程执行的逻辑
     */
    @Override
    public void run() {
        for (int i = 0; i < 10; i++) {
            System.out.println(getName()+"：正在执行！"+i);
        }
    }
}
//每次新创建子线程，都需要新创建一个MyThread对象
```

2. 实现Runable接口

```java
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for (int i = 0; i < 20; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
}
//Thread抽象类也是实现了Runnable接口的
//最终也还是通过Thread对象的thread()方法来运行
```

3. 匿名内部类

```java
    new Thread("新的线程！"){
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println(getName()+"：正在执行！"+i);
            }
        }
    }.start();
```

```java
    new Thread(new Runnable(){
        @Override
        public void run() {
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName()+"：" + i);
            }
        }
    }).start();
```

4. **Thread类**

- 构造方法

`Thread()`  `Thread(String name)`  `Thread(Runnable target)` `Thread(Runnable target,String name)`

- 其他方法

```java
run() 	getName()	
public static Thread currentThread():返回当前正在执行线程对象的引用
public final boolean isAlive():测试线程是否处于活跃状态
public final int getPriority():返回线程优先级
public final void setPriority(int newPriority):改变优先级
    MAX_PRIORITY(10); MIN_PRIORITY(1); NORM_PRIORITY(5)
    
start() 	sleep(long millis)
public static void yield():yield只是让线程暂停一下，让系统的线程调度器重新调度一次，不能保证该线程不会接着被线程调度器重新调度出来继续执行
void join():等待该线程终止,调用该方法的线程对象插队,等待该线程终止后，其他线程才会继续执行
void join(long millis):等待时间最长为millis毫秒，如果时间到了，其他线程不再等待
void join(long millis,int nanos):等待时间为millis毫秒+nanos纳秒
```

***

5. 线程其他注意点

> 线程的死亡有两种：
>
> 自然死亡：当一个线程的run方法执行完，线程自然会停止。
>
> 意外死亡：当一个线程遇到未捕获处理的异常，也会挂掉。
>
> **注意**  其他结束方式：stop()方法或者设置标记 

***

> 守护线程：在后台运行，任务是为其他线程提供服务；JVM的垃圾回收就是典型的守护线程；
>
> 特点：所有非守护线程都死亡，则守护线程自动死亡（比如守护线程里有`try-catch-finally` 语句，若该守护线程死亡了，则 `finally` 里的代码也不会执行）
>
> 如何设置为守护进程：`setDaemon(true)`

***



###### ***2. 线程安全(难点)***

> 多个线程访问同一资源时，就需要考虑线程安全问题

![image-20220326145747473](http://ybll.vip/md-imgs/202203291309622.png)

> 同步机制原理
>
> 同步机制的原理，其实就相当于给某段代码加“锁”，任何线程想要执行这段代码，都要先获得“锁”，我们称为它同步锁。因为Java对象在堆中的数据分为分为对象头、实例变量、空白的填充。而对象头中包含：
>
> - Mark Word：记录了和当前对象有关的GC、锁标记等信息。
> - 指向类的指针：每一个对象需要记录它是由哪个类创建出来的。
> - 数组长度（只有数组对象才有）
>
> 哪个线程获得了“同步锁”对象之后，”同步锁“对象就会记录这个线程的ID，这样其他线程就只能等待了，除非这个线程”释放“了锁对象，其他线程才能重新获得/占用”同步锁“对象。

> **关键字 `synchronized`**
>
> - 同步方法：public synchronized void method(){}
>
> - 同步代码块：synchronized(同步锁) {//需要同步操作的代码}
>
> **同步锁对象的选择：** 可以是任意类型，当必须保证竞争资源的多个线程是同一个"同步锁对象"
>
> - 同步代码块：手动指定
>
>   ​	在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器；
>   ​       在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类充当同步监视器。
>
> - 同步方法：系统默认
>
>   - 静态方法：当前类的Class对象
>   - 非静态方法：this(当前对象)
>
> - lock锁 （jdk5.0新增，没有使用synchronized）
>
> - 使用的优先顺序：
>
>   * Lock ---> 同步代码块（已经进入了方法体，分配了相应资源 ) ---> 同步方法（在方法体之外)

***

***代码演示***

**示例一：静态方法加锁**

```java
package com.atguigu.safe;

public class SaleTicketDemo3 {
    public static void main(String[] args) {
        TicketSaleThread t1 = new TicketSaleThread();
        TicketSaleThread t2 = new TicketSaleThread();
        TicketSaleThread t3 = new TicketSaleThread();

        t1.start();
        t2.start();
        t3.start();
    }
}

class TicketSaleThread extends Thread{
    private static int total = 100;
    public void run(){//直接锁这里，肯定不行，会导致，只有一个窗口卖票
        while(total>0) {
            saleOneTicket();
        }
    }

    public synchronized static void saleOneTicket(){//锁对象是TicketSaleThread类的Class对象，而一个类的Class对象在内存中肯定只有一个
        if(total > 0) {//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决
            System.out.println(Thread.currentThread().getName() + "卖出一张票，剩余:" + --total);
        }
    }
}

```

**示例二：非静态方法加锁**

```java
package com.atguigu.safe;

public class SaleTicketDemo4 {
    public static void main(String[] args) {
        TicketSaleRunnable tr = new TicketSaleRunnable();
        Thread t1 = new Thread(tr, "窗口一");
        Thread t2 = new Thread(tr, "窗口二");
        Thread t3 = new Thread(tr, "窗口三");

        t1.start();
        t2.start();
        t3.start();
    }
}

class TicketSaleRunnable implements Runnable {
    private int total = 1000;

    public void run() {//直接锁这里，肯定不行，会导致，只有一个窗口卖票
        while (total > 0) {
            saleOneTicket();
        }
    }
    public synchronized void saleOneTicket(){//锁对象是this，这里就是TicketSaleRunnable对象，因为上面3个线程使用同一个TicketSaleRunnable对象，所以可以
        if(total > 0) {//不加条件，相当于条件判断没有进入锁管控，线程安全问题就没有解决
            System.out.println(Thread.currentThread().getName() + "卖出一张票，剩余:" + --total);
        }
    }
}
```

**示例三：同步代码块**

```java
package com.atguigu.safe;

public class SaleTicketDemo5 {
    public static void main(String[] args) {
        //2、创建资源对象
        Ticket ticket = new Ticket();

        //3、启动多个线程操作资源类的对象
        Thread t1 = new Thread("窗口一") {
            public void run() {//不能给run()直接加锁，因为t1,t2,t3的三个run方法分别属于三个Thread类对象，
                                // run方法是非静态方法，那么锁对象默认选this，那么锁对象根本不是同一个
                while (true) {
                    synchronized (ticket) {
                        ticket.sale();
                    }
                }
            }
        };
        Thread t2 = new Thread("窗口二") {
            public void run() {
                while (true) {
                    synchronized (ticket) {
                        ticket.sale();
                    }
                }
            }
        };
        Thread t3 = new Thread(new Runnable() {
            public void run() {
                synchronized (ticket) {
                    ticket.sale();
                }
            }
        }, "窗口三");


        t1.start();
        t2.start();
        t3.start();
    }
}

//1、编写资源类
class Ticket {
    private int total = 1000;

    public  void sale() {//也可以直接给这个方法加锁，锁对象是this，这里就是Ticket对象
        if (total > 0) {
            System.out.println(Thread.currentThread().getName() + "卖出一张票，剩余:" + --total);
        } else {
            throw new RuntimeException("没有票了");
        }
    }

    public int getTotal() {
        return total;
    }
}
```

###### ***3. 等待唤醒机制***

> **为什么要处理线程间通信：**
>
> 多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。而多个线程并发执行时, 在默认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律的执行, 那么多线程之间需要一些通信机制，可以协调它们的工作，以此来帮我们达到多线程共同操作一份数据。
>
> 比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间就需要线程通信，即—— **等待唤醒机制。**

***

> **什么是等待唤醒机制**
>
> 这是多个线程间的一种**协作**机制。谈到线程我们经常想到的是线程间的**竞争**，比如去争夺锁；但这并不是故事的全部，线程间也会有协作机制。
>
> 就是在一个线程满足某个条件时，就进入等待状态（**wait()**/**wait(time)**）， 等待其他线程执行完他们的指定代码过后再将其唤醒（**notify()**）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程进行等待时，如果需要，可以使用 notifyAll()来唤醒所有的等待线程。`wait/notify` 就是线程间的一种协作机制
>
> 1.线程通信涉及到的三个方法：
> * wait():一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器。
> * notify():一旦执行此方法，就会唤醒被wait的一个线程。如果有多个线程被wait，就唤醒优先级高的那个。
> * notifyAll():一旦执行此方法，就会唤醒所有被wait的线程。
>
> 2.说明：
> - **wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中。**
>
> * wait()，notify()，notifyAll()三个方法的**调用者必须是同步代码块或同步方法中的同步监视器**。否则，会出现IllegalMonitorStateException异常
> * 3.wait()，notify()，notifyAll()三个方法是定义在 `java.lang.Object` 类中。

***

***代码实例***

```java
public class TestCommunicate2 {
	public static void main(String[] args) {
		// 1、创建资源类对象
		WindowBoard windowBoard = new WindowBoard();

		// 2、创建和启动厨师线程
		// 3、创建和启动服务员线程
		Cook c1 = new Cook("张三",windowBoard);
		Cook c2 = new Cook("李四",windowBoard);
		Waiter w1 = new Waiter("小红",windowBoard);
		Waiter w2 = new Waiter("小绿",windowBoard);
		
		c1.start();
		c2.start();
		w1.start();
		w2.start();
	}

}
//1、定义资源类
class WindowBoard {
	private static final int MAX_VALUE = 10;
	private int num;

	public synchronized void put() {
		while (num >= MAX_VALUE) {
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		num++;
		System.out.println(Thread.currentThread().getName() + "制作了一份快餐，现在工作台上有：" + num + "份快餐");
		this.notifyAll();
	}

	public synchronized void take() {
		while (num <= 0) {
			try {
				this.wait();
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		num--;
		System.out.println(Thread.currentThread().getName() + "取走了一份快餐，现在工作台上有：" + num + "份快餐");
		this.notifyAll();
	}
}


//2、定义厨师类
class Cook extends Thread{
	private WindowBoard windowBoard;
	
	public Cook(String name,WindowBoard windowBoard) {
		super(name);
		this.windowBoard = windowBoard;
	}

	public void run(){
		while(true) {
			windowBoard.put();
		}
	}
}


//3、定义服务员类
class Waiter extends Thread{
	private WindowBoard windowBoard;
	
	public Waiter(String name,WindowBoard windowBoard) {
		super(name);
		this.windowBoard = windowBoard;
	}

	public void run(){
		while(true) {
			windowBoard.take();
		}
	}
}
```

***

###### ***4. 线程生命周期***

##### 3. 基础API与常见算法

###### 数学相关的类

> 1. `java.lang.Math` 
>
> ***
>
> 2. `java.math 包`
>
> > 1. `BigInteger` :不可变的任意精度的整数
> >
> >    ```java
> >    	@Test
> >    	public void test01(){
> >    //		long bigNum = 123456789123456789123456789L;
> >    		
> >    		BigInteger b1 = new BigInteger("123456789123456789123456789");
> >    		BigInteger b2 = new BigInteger("78923456789123456789123456789");
> >    		
> >    //		System.out.println("和：" + (b1+b2));//错误的，无法直接使用 + 进行求和
> >    		
> >    		System.out.println("和：" + b1.add(b2));
> >    		System.out.println("减：" + b1.subtract(b2));
> >    		System.out.println("乘：" + b1.multiply(b2));
> >    		System.out.println("除：" + b2.divide(b1));
> >    		System.out.println("余：" + b2.remainder(b1));
> >    	}
> >    ```
> >
> > 2. `RoundingMode` 枚举类
> >
> >    > CEILING ：向正无限大方向舍入的舍入模式。 
> >    >
> >    > DOWN ：向零方向舍入的舍入模式。 
> >    >
> >    > FLOOR：向负无限大方向舍入的舍入模式。 
> >    >
> >    > HALF_DOWN ：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向下舍入。 
> >    >
> >    > HALF_EVEN：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向相邻的偶数舍入。
> >    >
> >    >
> >    > HALF_UP：向最接近数字方向舍入的舍入模式，如果与两个相邻数字的距离相等，则向上舍入。 
> >    >
> >    > UNNECESSARY：用于断言请求的操作具有精确结果的舍入模式，因此不需要舍入。 
> >    > UP：远离零方向舍入的舍入模式。
> >
> > 3. `BigDecimal` ：不可变的、任意精度的有符号十进制数
> >
> >    > * BigDecimal(String val) 
> >    > * BigDecimal add(BigDecimal val) 
> >    > * BigDecimal subtract(BigDecimal val)
> >    > * BigDecimal multiply(BigDecimal val) 
> >    > * BigDecimal divide(BigDecimal val) 
> >    > * BigDecimal divide(BigDecimal divisor, int roundingMode) 
> >    > * BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) 
> >    > * BigDecimal remainder(BigDecimal val) 
> >
> >    ```java
> >    	@Test
> >    	public void test02(){
> >    		/*double big = 12.123456789123456789123456789;
> >    		System.out.println("big = " + big);*/
> >    		
> >    		BigDecimal b1 = new BigDecimal("123.45678912345678912345678912345678");
> >    		BigDecimal b2 = new BigDecimal("7.8923456789123456789123456789998898888");
> >    		
> >    //		System.out.println("和：" + (b1+b2));//错误的，无法直接使用+进行求和
> >    		
> >    		System.out.println("和：" + b1.add(b2));
> >    		System.out.println("减：" + b1.subtract(b2));
> >    		System.out.println("乘：" + b1.multiply(b2));
> >    		System.out.println("除：" + b1.divide(b2,20,RoundingMode.UP));//divide(BigDecimal divisor, int scale, int roundingMode)
> >    		System.out.println("除：" + b1.divide(b2,20,RoundingMode.DOWN));//divide(BigDecimal divisor, int scale, int roundingMode)
> >    		System.out.println("余：" + b1.remainder(b2));
> >    	}
> >    ```
>
> ***
>
> 3. `java.util.Random` : 用于随机产生随机数
>
> > * boolean nextBoolean():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 boolean 值。 
> > * void nextBytes(byte[] bytes):生成随机字节并将其置于用户提供的 byte 数组中。 
> > * double nextDouble():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 double 值。 
> > * float nextFloat():返回下一个伪随机数，它是取自此随机数生成器序列的、在 0.0 和 1.0 之间均匀分布的 float 值。 
> > * int nextInt():返回下一个伪随机数，它是此随机数生成器的序列中均匀分布的 int 值。 
> > * int nextInt(int n):返回一个伪随机数，它是取自此随机数生成器序列的、在 0（包括）和指定值（不包括）之间均匀分布的 int 值。 
> > * long nextLong():返回下一个伪随机数，它是取自此随机数生成器序列的均匀分布的 long 值。 
> > 
> >```java
> > @Test
> > 	public void test03(){
> > 		Random r = new Random();
> > 		System.out.println("随机整数：" + r.nextInt());
> > 		System.out.println("随机小数：" + r.nextDouble());
> > 		System.out.println("随机布尔值：" + r.nextBoolean());
> > 	}
> > ```

***

###### 日期时间API

> ***JDK1.8前***
>
> > `java.util.Date`
> >
> > new Date()：当前系统时间 	new Date(long 毫秒)
> >
> > long getTime():1970-1-1  0.0.0 0 毫秒 到现在的毫秒数
> >
> > ***
> >
> > `java.text.SimpleDateFormat` : 用于日期时间的格式化
> >
> > ![image-20220329144842983](http://ybll.vip/md-imgs/202203291448485.png)
> >
> > ```java
> > @Test
> > 	public void test10() throws ParseException{
> > 		String str = "2019年06月06日 16时03分14秒 545毫秒  星期四 +0800";
> > 		SimpleDateFormat sf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z");
> > 		Date d = sf.parse(str);
> > 		System.out.println(d);
> > 	}
> > 	
> > 	@Test
> > 	public void test9(){
> > 		Date d = new Date();
> > 
> > 		SimpleDateFormat sf = new SimpleDateFormat("yyyy年MM月dd日 HH时mm分ss秒 SSS毫秒  E Z");
> > 		//把Date日期转成字符串，按照指定的格式转
> > 		String str = sf.format(d);
> > 		System.out.println(str);
> > 	}
> > ```
> >
> > ***
> >
> > `java.util.Calendar` 抽象类，为特定瞬间与一组如 YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段提供转换
> >
> > ```java
> > import org.junit.Test;
> > 
> > import java.util.Calendar;
> > import java.util.TimeZone;
> > 
> > public class TestCalendar {
> >     @Test
> >     public void test1(){
> >         Calendar c = Calendar.getInstance();
> >         System.out.println(c);
> > 
> >         int year = c.get(Calendar.YEAR);
> >         int month = c.get(Calendar.MONTH)+1;
> >         int day = c.get(Calendar.DATE);
> >         int hour = c.get(Calendar.HOUR_OF_DAY);
> >         int minute = c.get(Calendar.MINUTE);
> > 
> >         System.out.println(year + "-" + month + "-" + day + " " + hour + ":" + minute);
> >     }
> > 
> >     @Test
> >     public void test2(){
> >         TimeZone t = TimeZone.getTimeZone("America/Los_Angeles");
> >         Calendar c = Calendar.getInstance(t);
> >         int year = c.get(Calendar.YEAR);
> >         int month = c.get(Calendar.MONTH)+1;
> >         int day = c.get(Calendar.DATE);
> >         int hour = c.get(Calendar.HOUR_OF_DAY);
> >         int minute = c.get(Calendar.MINUTE);
> > 
> >         System.out.println(year + "-" + month + "-" + day + " " + hour + ":" + minute);
> >     }
> > }
> > ```
>
> ***JDK1.8后***
>
> > Java1.0中包含了一个Date类，但是它的大多数方法已经在Java 1.1引入Calendar类之后被弃用了。而Calendar并不比Date好多少。它们面临的问题是：
> >
> > * 可变性：象日期和时间这样的类对象应该是不可变的。Calendar类中可以使用三种方法更改日历字段：set()、add() 和 roll()。
> > * 偏移性：Date中的年份是从1900开始的，而月份都是从0开始的。
> > * 格式化：格式化只对Date有用，Calendar则不行。
> > * 此外，它们也不是线程安全的，不能处理闰秒等。
> >
> > 可以说，对日期和时间的操作一直是Java程序员最痛苦的地方之一。第三次引入的API是成功的，并且java 8中引入的java.time API 已经纠正了过去的缺陷，将来很长一段时间内它都会为我们服务。
> >
> > Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。
> >
> > * java.time – 包含值对象的基础包
> > * java.time.chrono – 提供对不同的日历系统的访问。
> > * java.time.format – 格式化和解析时间和日期
> > * java.time.temporal – 包括底层框架和扩展特性
> > * java.time.zone – 包含时区支持的类
> >
> > Java 8 吸收了 Joda-Time 的精华，以一个新的开始为 Java 创建优秀的 API。新的 java.time 中包含了所有关于时钟（Clock），本地日期（LocalDate）、本地时间（LocalTime）、本地日期时间（LocalDateTime）、时区（ZonedDateTime）和持续时间（Duration）的类。
>
> ***
>
> > **1、本地日期时间：LocalDate、LocalTime、LocalDateTime**
> >
> > | 方法                                                         | **描述**                                                     |
> > | ------------------------------------------------------------ | ------------------------------------------------------------ |
> > | now() / now(ZoneId zone)                                     | 静态方法，根据当前时间创建对象/指定时区的对象                |
> > | of()                                                         | 静态方法，根据指定日期/时间创建对象                          |
> > | getDayOfMonth()/getDayOfYear()                               | 获得月份天数(1-31) /获得年份天数(1-366)                      |
> > | getDayOfWeek()                                               | 获得星期几(返回一个 DayOfWeek 枚举值)                        |
> > | getMonth()                                                   | 获得月份, 返回一个 Month 枚举值                              |
> > | getMonthValue() / getYear()                                  | 获得月份(1-12) /获得年份                                     |
> > | getHours()/getMinute()/getSecond()                           | 获得当前对象对应的小时、分钟、秒                             |
> > | withDayOfMonth()/withDayOfYear()/withMonth()/withYear()      | 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 |
> > | with(TemporalAdjuster  t)                                    | 将当前日期时间设置为校对器指定的日期时间                     |
> > | plusDays(), plusWeeks(), plusMonths(), plusYears(),plusHours() | 向当前对象添加几天、几周、几个月、几年、几小时               |
> > | minusMonths() / minusWeeks()/minusDays()/minusYears()/minusHours() | 从当前对象减去几月、几周、几天、几年、几小时                 |
> > | plus(TemporalAmount t)/minus(TemporalAmount t)               | 添加或减少一个 Duration 或 Period                            |
> > | isBefore()/isAfter()                                         | 比较两个 LocalDate                                           |
> > | isLeapYear()                                                 | 判断是否是闰年（在LocalDate类中声明）                        |
> > | format(DateTimeFormatter  t)                                 | 格式化本地日期、时间，返回一个字符串                         |
> > | parse(Charsequence text)                                     | 将指定格式的字符串解析为日期、时间                           |
> >
> > ```java
> > import org.junit.Test;
> > 
> > import java.time.LocalDate;
> > import java.time.LocalDateTime;
> > import java.time.LocalTime;
> > 
> > public class TestLocalDateTime {
> >     @Test
> >     public void test7(){
> >         LocalDate now = LocalDate.now();
> >         LocalDate before = now.minusDays(100);
> >         System.out.println(before);//2019-02-26
> >     }
> > 
> >     @Test
> >     public void test06(){
> >         LocalDate lai = LocalDate.of(2019, 5, 13);
> >         LocalDate go = lai.plusDays(160);
> >         System.out.println(go);//2019-10-20
> >     }
> > 
> >     @Test
> >     public void test05(){
> >         LocalDate lai = LocalDate.of(2019, 5, 13);
> >         System.out.println(lai.getDayOfYear());
> >     }
> > 
> > 
> >     @Test
> >     public void test04(){
> >         LocalDate lai = LocalDate.of(2019, 5, 13);
> >         System.out.println(lai);
> >     }
> > 
> >     @Test
> >     public void test03(){
> >         LocalDateTime now = LocalDateTime.now();
> >         System.out.println(now);
> >     }
> > 
> >     @Test
> >     public void test02(){
> >         LocalTime now = LocalTime.now();
> >         System.out.println(now);
> >     }
> > 
> >     @Test
> >     public void test01(){
> >         LocalDate now = LocalDate.now();
> >         System.out.println(now);
> >     }
> > }
> > ```
> >
> > **2、持续日期/时间：Period和Duration**
> >
> > Period:用于计算两个“日期”间隔
> >
> > Duration:用于计算两个“时间”间隔
> >
> > ```java
> > import org.junit.Test;
> > 
> > import java.time.Duration;
> > import java.time.LocalDate;
> > import java.time.LocalDateTime;
> > import java.time.Period;
> > 
> > public class TestPeriodDuration {
> >     @Test
> >     public void test01(){
> >         LocalDate t1 = LocalDate.now();
> >         LocalDate t2 = LocalDate.of(2018, 12, 31);
> >         Period between = Period.between(t1, t2);
> >         System.out.println(between);
> > 
> >         System.out.println("相差的年数："+between.getYears());
> >         System.out.println("相差的月数："+between.getMonths());
> >         System.out.println("相差的天数："+between.getDays());
> >         System.out.println("相差的总数："+between.toTotalMonths());
> >     }
> > 
> >     @Test
> >     public void test02(){
> >         LocalDateTime t1 = LocalDateTime.now();
> >         LocalDateTime t2 = LocalDateTime.of(2017, 8, 29, 0, 0, 0, 0);
> >         Duration between = Duration.between(t1, t2);
> >         System.out.println(between);
> > 
> >         System.out.println("相差的总天数："+between.toDays());
> >         System.out.println("相差的总小时数："+between.toHours());
> >         System.out.println("相差的总分钟数："+between.toMinutes());
> >         System.out.println("相差的总秒数："+between.getSeconds());
> >         System.out.println("相差的总毫秒数："+between.toMillis());
> >         System.out.println("相差的总纳秒数："+between.toNanos());
> >         System.out.println("不够一的纳秒数："+between.getNano());
> >     }
> > }
> > ```
> >

***

###### 系统相关类

> 系统类中很多好用的方法，其中几个如下：
>
> * static long currentTimeMillis() ：返回当前系统时间距离1970-1-1 0:0:0的毫秒值
> * static void exit(int status) ：退出当前系统
> * static void gc() ：运行垃圾回收器。
> * static String getProperty(String key)：获取某个系统属性，例如：java.version、user.language、user.country、file.encoding、user.name、os.version、os.name等等

```
import org.junit.Test;

public class TestSystem {
    @Test
    public void test01(){
        long time = System.currentTimeMillis();
        System.out.println("现在的系统时间距离1970年1月1日凌晨：" + time + "毫秒");

        System.exit(0);

        System.out.println("over");//不会执行
    }

    @Test
    public void test02(){
        System.out.println(System.getProperty("java.version"));
        System.out.println(System.getProperty("user.language"));
        System.out.println(System.getProperty("user.country"));
        System.out.println(System.getProperty("file.encoding"));
        System.out.println(System.getProperty("user.name"));
        System.out.println(System.getProperty("os.version"));
        System.out.println(System.getProperty("os.name"));
    }

    @Test
    public void test03() throws InterruptedException {
        for (int i=1; i <=10; i++){
            MyDemo my = new MyDemo(i);
            //每一次循环my就会指向新的对象，那么上次的对象就没有变量引用它了，就成垃圾对象
        }

        //为了看到垃圾回收器工作，我要加下面的代码，让main方法不那么快结束，因为main结束就会导致JVM退出，GC也会跟着结束。
        System.gc();//如果不调用这句代码，GC可能不工作，因为当前内存很充足，GC就觉得不着急回收垃圾对象。
        //调用这句代码，会让GC尽快来工作。
        Thread.sleep(5000);
    }
}

class MyDemo{
    private int value;

    public MyDemo(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return "MyDemo{" + "value=" + value + '}';
    }

    //重写finalize方法，让大家看一下它的调用效果
    @Override
    protected void finalize() throws Throwable {
//        正常重写，这里是编写清理系统内存的代码
//        这里写输出语句是为了看到finalize()方法被调用的效果
        System.out.println(this+ "轻轻的走了，不带走一段代码....");
    }
}
```

***

###### 数组工具类

> `java.util.Arrays` ：数组工具类   ,下面方法都可以带泛型或者Object[]数组,以int[]举例
>
> > static String toString(int[]a) //[元素1,元素2,...]
> > static sort(int[] a)
> > static void sort(int[] a,int fromIndex,int toIndex)
> > static <T> void sort(T[] a, Comparator<? super T> c)//根据指定比较器产生的顺序对指定对象进行排序
> >
> > static int binarySearch(int[] a , int key)
> >
> > static int[] copyOf(int[] original, int newLength) :根据原数组，复制一个长为newLength的新数组，返回新数组
> >
> > static int[] copyOfRange(int[] original,int from,int to)
> >
> > static boolean equals(int[]a,int[]a2)
> >
> > static void fill(int[] a,int val) //用val填充整个a数组
> >
> > static void fill(int[] a,int fromIndex,int toIndex,int val) //范围填充，取头不取尾
> >
> > ```java
> >      @Test
> >     public void test01() {
> >         int[] arr = {1, 2, 3, 4, 5};
> >         System.out.println(Arrays.toString(arr));
> >     Student[] students = new Student[3];
> >     students[0] = new Student("张三", 96);
> >     students[1] = new Student("李四", 85);
> >     students[2] = new Student("王五", 98);
> >     System.out.println(Arrays.toString(students));
> > }
> > 
> > @Test
> > public void test02() {
> >     int[] arr = {3, 2, 5, 1, 6};
> >     System.out.println("排序前" + Arrays.toString(arr));
> >     Arrays.sort(arr);
> >     System.out.println("排序后" + Arrays.toString(arr));
> > 
> >     Student[] students = new Student[3];
> >     students[0] = new Student("张三", 96);
> >     students[1] = new Student("李四", 85);
> >     students[2] = new Student("王五", 98);
> > 
> >     System.out.println(Arrays.toString(students));
> >     Arrays.sort(students);
> >     System.out.println(Arrays.toString(students));
> >     Arrays.sort(students, new Comparator() {
> >         @Override
> >         public int compare(Object o1, Object o2) {
> >             return Collator.getInstance(Locale.CHINA).compare(((Student) o1).getName(), ((Student) o2).getName());
> >         }
> >     });
> >     System.out.println(Arrays.toString(students));
> > }
> > 
> > @Test
> > public void test03() {
> >     int[] arr1 = {1, 2, 3, 4, 5};
> >     int[] arr2 = {1, 2, 3, 4, 5};
> >     System.out.println(Arrays.equals(arr1, arr2));
> > }
> > 
> > @Test
> > public void test04() {
> >     int[] arr1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
> >     int[] arr2 = Arrays.copyOf(arr1, 5);
> >     int[] arr3 = Arrays.copyOfRange(arr1, 3, 8);
> >     System.out.println(Arrays.toString(arr2));
> >     System.out.println(Arrays.toString(arr3));
> > 
> >     Arrays.fill(arr1, 5, 9, 3);
> >     System.out.println(Arrays.toString(arr1));
> > }
> > ```

***

###### ***字符串String***

> `java.lang.String` 类代表字符串。Java程序中所有的字符串文字（例如`"abc"` ）都可以被看作是实现此类的实例。字符串是常量；它们的值在创建之后不能更改。字符串缓冲区支持可变的字符串。因为 String 对象是不可变的，所以可以共享。
>
> `String` 类包括的方法可用于检查序列的单个字符、比较字符串、搜索字符串、提取子字符串、创建字符串副本并将所有字符全部转换为大写或小写。 
>
> Java 语言提供对字符串串联符号（"+"）以及将其他对象转换为字符串的特殊支持（toString()方法）。
>
> 特点：
>
> + String类是final声明的，不能继承
> + 字符串对象是不可变对象，不能修改，一旦修改，就会产生新对象
> + String对象内部是字符数组进行保存的
>   + JDK1.9前是char[] value数组，且用final修饰
>   + JDk1.9后是byte[] value数组，还是final修饰
>   + char data[]= {'a','b','c'}  等效与 "abc"
> + String对象是不可变的，所以字符串有常量池(**在方法区，jdk版本不一样，有所变化**)来保存很多常量对象
>
> ***
>
> 1. **构造字符串对象**
>
> > + 构造方法
> >
> >   + public String()
> >
> >   + String(String original)
> >
> >   + public String (char[] value)
> >
> >   + public String (char[] value,int offset,int count)
> >
> >   + public String (byte[] bytes)
> >
> >   + public String (byte[] bytes,String charsetName)
> >
> >   + ```java
> >     //字符串常量对象
> >     String str = "hello";
> >     
> >     // 无参构造
> >     String str1 = new String（）；
> >     
> >     //创建"hello"字符串常量的副本
> >     String str2 = new String("hello");
> >     
> >     //通过字符数组构造
> >     char chars[] = {'a', 'b', 'c','d','e'};     
> >     String str3 = new String(chars);
> >     String str4 = new String(chars,0,3);
> >     
> >     // 通过字节数组构造
> >     byte bytes[] = {97, 98, 99 };     
> >     String str5 = new String(bytes);
> >     String str6 = new String(bytes,"GBK");
> >     ```
> >
> > + 静态方法
> >
> >   * static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String
> >   * static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String
> >   * static String valueOf(char[] data)  ： 返回指定数组中表示该字符序列的 String
> >   * static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String
> >   * static String valueOf(xx  value)：xx支持各种数据类型，返回各种数据类型的value参数的字符串表示形式。
> >
> >   ```java
> >   	public static void main(String[] args) {
> >   		char[] data = {'h','e','l','l','o','j','a','v','a'};
> >   		String s1 = String.copyValueOf(data);
> >   		String s2 = String.copyValueOf(data,0,5);
> >   		int num = 123456;
> >   		String s3 = String.valueOf(num);
> >   		System.out.println(s1);
> >   		System.out.println(s2);
> >   		System.out.println(s3);
> >   	}
> >   ```
> >
> > + 使用 "+"
>
> ***
>
> 2. **字符换对象内存分析**
>
> > ```java
> > String s;
> > 
> > String s = null;
> > 
> > String s = "";
> > String s = new String();
> > String s = new String("");
> > 
> > String s = "abc";
> > String s = new String("abc");
> > 
> > char[] arr = {'a','b'};
> > String s = new String(arr);
> > 
> > 
> > char[] arr = {'a','b','c','d','e'};
> > String s = new String(arr,0,3);
> > ```
> >
> > ![image-20220329185557651](http://ybll.vip/md-imgs/202203291856052.png)
>
> ***
>
> 3. **字符串拼接问题**
>
> 原则：
>
> （1）常量+常量：结果是常量池
>
> （2）常量与变量 或 变量与变量：结果是堆
>
> （3）拼接后调用intern方法：结果在常量池
>
> ```java
> 	@Test
> 	public void test06(){
> 		String s1 = "hello";
> 		String s2 = "world";
> 		String s3 = "helloworld";
> 		
> 		String s4 = (s1 + "world").intern();//把拼接的结果放到常量池中
> 		String s5 = (s1 + s2).intern();
> 		
> 		System.out.println(s3 == s4);//true
> 		System.out.println(s3 == s5);//true
> 	}
> 	
> 	@Test
> 	public void test05(){
> 		final String s1 = "hello";
> 		final String s2 = "world";
> 		String s3 = "helloworld";
> 		
> 		String s4 = s1 + "world";//s4字符串内容也helloworld，s1是常量，"world"常量，常量+ 常量 结果在常量池中
> 		String s5 = s1 + s2;//s5字符串内容也helloworld，s1和s2都是常量，常量+ 常量 结果在常量池中
> 		String s6 = "hello" + "world";//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果
> 		
> 		System.out.println(s3 == s4);//true
> 		System.out.println(s3 == s5);//true
> 		System.out.println(s3 == s6);//true
> 	}
> 	
> 	@Test
> 	public void test04(){
> 		String s1 = "hello";
> 		String s2 = "world";
> 		String s3 = "helloworld";
> 		
> 		String s4 = s1 + "world";//s4字符串内容也helloworld，s1是变量，"world"常量，变量 + 常量的结果在堆中
> 		String s5 = s1 + s2;//s5字符串内容也helloworld，s1和s2都是变量，变量 + 变量的结果在堆中
> 		String s6 = "hello" + "world";//常量+ 常量 结果在常量池中，因为编译期间就可以确定结果
> 		
> 		System.out.println(s3 == s4);//false
> 		System.out.println(s3 == s5);//false
> 		System.out.println(s3 == s6);//true
> 	}
> ```
>
> ![image-20220329185845313](http://ybll.vip/md-imgs/202203291858193.png)
>
> ***
>
> ```java
> public class TestString {
> 	public static void main(String[] args) {
> 		String str = "hello";
> 		String str2 = "world";
> 		String str3 ="helloworld";
> 		
> 		String str4 = "hello".concat("world");
> 		String str5 = "hello"+"world";
> 		
> 		System.out.println(str3 == str4);//false
> 		System.out.println(str3 == str5);//true
> 	}
> }
> ```
>
> > concat方法拼接，哪怕是两个常量对象拼接，结果也是在堆。
>
> ***
>
> 4. **字符串比较**
>
> > + ==：比较是对象的地址
> >
> > > 只有两个字符串变量都是指向字符串的常量对象时，才会返回true
> >
> > ```java
> > String str1 = "hello";
> > String str2 = "hello";
> > System.out.println(str1 == str2);//true
> >     
> > String str3 = new String("hello");
> > String str4 = new String("hello");
> > System.out.println(str1 == str4); //false
> > System.out.println(str3 == str4); //false
> > ```
> >
> > + equals：比较是对象的内容，因为String类型重写equals，区分大小写
> >
> > 只要两个字符串的字符内容相同，就会返回true
> >
> > ```java
> > String str1 = "hello";
> > String str2 = "hello";
> > System.out.println(str1.equals(str2));//true
> >     
> > String str3 = new String("hello");
> > String str4 = new String("hello");
> > System.out.println(str1.equals(str3));//true
> > System.out.println(str3.equals(str4));//true
> > ```
> >
> > + equalsIgnoreCase：比较的是对象的内容，不区分大小写
> >
> > ```java
> > String str1 = new String("hello");
> > String str2 = new String("HELLO");
> > System.out.println(str1.equalsIgnoreCase(strs)); //true
> > ```
> >
> > + compareTo：String类型重写了Comparable接口的抽象方法，自然排序，按照字符的Unicode编码值进行比较大小的，严格区分大小写
> >
> > ```java
> > String str1 = "hello";
> > String str2 = "world";
> > str1.compareTo(str2) //小于0的值
> > ```
> >
> > + compareToIgnoreCase：不区分大小写，其他按照字符的Unicode编码值进行比较大小
> >
> > ```java
> > String str1 = new String("hello");
> > String str2 = new String("HELLO");
> > str1.compareToIgnoreCase(str2)  //等于0
> > ```
> >
>
> ***
>
> 5. **空字符的比较**
>
> + 哪些是空字符串
>
> ```java
> String str1 = "";
> String str2 = new String();
> String str3 = new String("");
> ```
>
> + + 空字符串：长度为0
>
> + 如何判断某个字符串是否是空字符串
>
> ```java
> if("".equals(str))
> 
> if(str!=null  && str.isEmpty())
> 
> if(str!=null && str.equals(""))
> 
> if(str!=null && str.length()==0)
> ```
>
> ***
>
> 6. **字符串的常用方法**
>
> > （1）boolean isEmpty()：字符串是否为空
> >
> > （2）int length()：返回字符串的长度
> >
> > （3）String concat(xx)：拼接，等价于+
> >
> > （4）boolean equals(Object obj)：比较字符串是否相等，区分大小写
> >
> > （5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写
> >
> > （6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小
> >
> > （7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写
> >
> > （8）String toLowerCase()：将字符串中大写字母转为小写
> >
> > （9）String toUpperCase()：将字符串中小写字母转为大写
> >
> > （10）String trim()：去掉字符串前后空白符
> >
> > （11）public String intern()：结果在常量池中共享
> >
> > （11）boolean contains(xx)：是否包含xx
> >
> > （12）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1
> >
> > （13）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1
> >
> > （14）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 
> >
> > （15）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 
> >
> > （16）char charAt(index)：返回[index]位置的字符
> >
> > （17）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回
> >
> > （18）String(char[] value)：返回指定数组中表示该字符序列的 String。 
> >
> > （19）String(char[] value, int offset, int count)：返回指定数组中表示该字符序列的 String。
> >
> > （20）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String
> >
> > （21）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String
> >
> > （22）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String
> >
> > （23）static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String
> >
> > （24）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码方式进行编码
> >
> > ​	        byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码
> >
> > （25）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码
> >
> > ​           new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码
> >
> > （26）boolean startsWith(xx)：是否以xx开头
> >
> > （27）boolean endsWith(xx)：是否以xx结尾
> >
> > （28）boolean matchs(正则表达式)：判断当前字符串是否匹配某个正则表达式。==（正则表达式见附录10.7.2）==
> >
> > （29）String replace(xx,xx)：不支持正则
> >
> > （30）String replaceFirst(正则，value)：替换第一个匹配部分
> >
> > （31）String repalceAll(正则， value)：替换所有匹配部分
> >
> > （32）String[] split(正则)：按照某种规则进行拆分
> >
> > > ```java
> > > @Test
> > > 	public void test4(){
> > > 		String str = "张三.23|李四.24|王五.25";
> > > 		//|在正则中是有特殊意义，我这里要把它当做普通的|
> > > 		String[] all = str.split("\\|");
> > > 		
> > > 		//转成一个一个学生对象
> > > 		Student[] students = new Student[all.length];
> > > 		for (int i = 0; i < students.length; i++) {
> > > 			//.在正则中是特殊意义，我这里想要表示普通的.
> > > 			String[] strings = all[i].split("\\.");//张三,  23
> > > 			String name = strings[0];
> > > 			int age = Integer.parseInt(strings[1]);
> > > 			students[i] = new Student(name,age);
> > > 		}
> > > 		
> > > 		for (int i = 0; i < students.length; i++) {
> > > 			System.out.println(students[i]);
> > > 		}
> > > 		
> > > 	}
> > > 	
> > > 	@Test
> > > 	public void test3(){
> > > 		String str = "1Hello2World3java4atguigu5";
> > > 		str = str.replaceAll("^\\d|\\d$", "");
> > > 		String[] all = str.split("\\d");
> > > 		for (int i = 0; i < all.length; i++) {
> > > 			System.out.println(all[i]);
> > > 		}
> > > 	}
> > > 	
> > > 	@Test
> > > 	public void test2(){
> > > 		String str = "1Hello2World3java4atguigu";
> > > 		str = str.replaceFirst("\\d", "");
> > > 		System.out.println(str);
> > > 		String[] all = str.split("\\d");
> > > 		for (int i = 0; i < all.length; i++) {
> > > 			System.out.println(all[i]);
> > > 		}
> > > 	}
> > > 	
> > > 	
> > > 	@Test
> > > 	public void test1(){
> > > 		String str = "Hello World java atguigu";
> > > 		String[] all = str.split(" ");
> > > 		for (int i = 0; i < all.length; i++) {
> > > 			System.out.println(all[i]);
> > > 		}
> > > 	}
> > > ```

***

###### 可变字符串



##### 4. 集合与迭代器

> 集合主要分为两大系列：Collection和Map，Collection 表示一组对象，Map表示一组映射关系或键值对。
>
> + 集合只能用于存储对象
> + 数组可以用于存储对象和基本数据类型

***

###### Collection接口

> Collection 层次结构中的根接口。Collection 表示一组对象，这些对象也称为 collection 的元素。一些 collection 允许有重复的元素，而另一些则不允许。一些 collection 是有序的，而另一些则是无序的。JDK 不提供此接口的任何直接实现：它提供更具体的子接口（如 Set 和 List、Queue）实现。此接口通常用来传递 collection，并在需要最大普遍性的地方操作这些 collection。 
>
> Collection<E>是所有单列集合的父接口，因此在Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合。
>
> 类关系图
>
> ![image-20220402091500162](http://ybll.vip/md-imgs/202204020915023.png)
>
> 方法如下：
>
> > add(E obj)
> >
> > addAll(Collection<? extends E> other) //添加other集合中的所有元素到当前集合
>
> ***
>
> > boolean remove(Object obj) //删除第一个与obj对象equals返回true的元素
> >
> > boolean removeAll(Collection<?> coll) //从当前集合删除所有与coll集合中相同的元素
> >
> > boolean removeIf(Predicate<? super E> filter)//删除满足给定条件的此集合中的所有元素
> >
> > boolean retainAll(Collection<?> coll)//当前集合仅保留两个集合的交集
> >
> > ```java
> > @Test
> >     public void test01(){
> >         Collection coll = new ArrayList();
> >         coll.add("小李广");
> >         coll.add("扫地僧");
> >         coll.add("石破天");
> >         coll.add("佛地魔");
> >         System.out.println("coll = " + coll);
> > 
> >         coll.remove("小李广");
> >         System.out.println("删除元素\"小李广\"之后coll = " + coll);
> > 
> >         coll.removeIf(new Predicate() {
> >             @Override
> >             public boolean test(Object o) {
> >                 String str = (String) o;
> >                 return str.contains("地");
> >             }
> >         });
> >         System.out.println("删除包含\"地\"字的元素之后coll = " + coll);
> > 
> >         coll.clear();
> >         System.out.println("coll清空之后，coll = " + coll);
> >     }
> > ```
>
> ***
>
> > boolean isEmpty() 
> >
> > boolean contains(Object obj) //判断当前集合是否存在一个与obj对象equals返回true的元素
> >
> > boolean containsAll(Collection<?> c) //判断集合c是否为当前集合的"子集"
> >
> > int size() //获取集合中实际存储的元素个数
> >
> > **Object[] toArray() //返回一个数组，包含集合所有元素**
> >
> > ```
> > @Test
> >     public void test03(){
> >         Collection c1 = new ArrayList();
> >         c1.add(1);
> >         c1.add(2);
> >         System.out.println("c1集合元素的个数：" + c1.size());//2
> >         System.out.println("c1 = " + c1);
> > 
> >         Collection c2 = new ArrayList();
> >         c2.add(1);
> >         c2.add(2);
> >         System.out.println("c2集合元素的个数：" + c2.size());//2
> >         System.out.println("c2 = " + c2);
> > 
> >         Collection other = new ArrayList();
> >         other.add(1);
> >         other.add(2);
> >         other.add(3);
> >         System.out.println("other集合元素的个数：" + other.size());//3
> >         System.out.println("other = " + other);
> >         System.out.println();
> > 
> >         c1.addAll(other);
> >         System.out.println("c1集合元素的个数：" + c1.size());//5
> >         System.out.println("c1.addAll(other) = " + c1);
> >         System.out.println("c1.contains(other) = " + c1.contains(other)); // false
> >         System.out.println("c1.containsAll(other) = " + c1.containsAll(other)); //true
> >         System.out.println();
> > 
> >         c2.add(other);
> >         System.out.println("c2集合元素的个数：" + c2.size()); //3
> >         System.out.println("c2.add(other) = " + c2);
> >         System.out.println("c2.contains(other) = " + c2.contains(other)); //true
> >         System.out.println("c2.containsAll(other) = " + c2.containsAll(other)); //false
> >     }
> > ```
>
> ***
>
> Iterator迭代器
>
> > 在程序开发中，经常需要遍历集合中的所有元素。针对这种需求，JDK专门提供了一个接口`java.util.Iterator`。`Iterator`接口也是Java集合中的一员，但它与`Collection`、`Map`接口有所不同，`Collection`接口与`Map`接口主要用于存储元素，而`Iterator`主要用于迭代访问（即遍历）`Collection`中的元素，因此`Iterator`对象也被称为迭代器。
> >
> > collection.iterator() //获取迭代器 public Iterator iterator()
> >
> > + public E next() //返回迭代的下一个元素
> >
> > + public boolean hasNext() //判断是否有下一个元素可以迭代
> > + public void remove() //使用迭代器删除元素（因为jdk1.8前，collection没有removeIf()方法)
> > + 提示：在进行集合元素取出时，如果集合中已经没有元素了，还继续使用迭代器的next方法，将会发生 `java.util.NoSuchElementException` 没有集合元素的错误。
> >
> > ![image-20220329235247462](http://ybll.vip/md-imgs/202203292352002.png)
>
> ***
>
> Iterator迭代器的快速失败（fail-fast）机制
>
> > ConcurrentModificationException异常
> >
> > > + 创建迭代器后，只能通过迭代器的方法(remove)修改集合，否则会抛出该异常
> > >
> > > + ```
> > >  @Test
> > >       public void testmyself2(){
> > >           Collection coll = new ArrayList();
> > >           coll.add("hello");
> > >           coll.add("world");
> > >           coll.add("java");
> > >           coll.add("haha");
> > >           coll.add("mysql");
> > >     
> > >           Iterator iterator = coll.iterator();
> > >           while(iterator.hasNext()){
> > >               String str = (String)iterator.next();
> > >               if(str.contains("a")){
> > >                   iterator.remove();//foreach遍历集合过程中，调用集合的remove方法
> > >               }
> > >   //            System.out.println(str);
> > >           }
> > >   
> > >   //        for (Object o : coll) {
> > >   //            String str = (String) o;
> > >   //            if(str.contains("a")){
> > >   //                coll.remove(o);//foreach遍历集合过程中，调用集合的remove方法
> > >   //            }
> > >   //        }
> > >       }
> > >   ```
> >
> > ***
> >
> > modCount变量
> >
> > > 那么迭代器如何实现快速失败（fail-fast）机制的呢？
> > >
> > > * 在ArrayList等集合类中都有一个modCount变量。它用来记录集合的结构被修改的次数。
> > > * 当我们给集合添加和删除操作时，会导致modCount++。
> > > * 然后当我们用Iterator迭代器遍历集合时，创建集合迭代器的对象时，用一个变量记录当前集合的modCount。例如：`int expectedModCount = modCount;`，并且在迭代器每次next()迭代元素时，都要检查 `expectedModCount != modCount`，如果不相等了，那么说明你调用了Iterator迭代器以外的Collection的add,remove等方法，修改了集合的结构，使得modCount++，值变了，就会抛出ConcurrentModificationException。
> > > * 注意，迭代器的快速失败行为不能得到保证，一般来说，存在不同步的并发修改时，不可能作出任何坚决的保证。快速失败迭代器尽最大努力抛出 `ConcurrentModificationException`。因此，编写依赖于此异常的程序的方式是错误的，正确做法是：*迭代器的快速失败行为应该仅用于检测 bug。*
> > >
> > > ![](http://ybll.vip/md-imgs/202203300910877.png)

***

###### List集合

> `java.util.List` 接口继承自 `Collection` 接口，是单列集合的一个重要分支，List集合类中元素有序、且可重复。
>
> 特点：
>
> - List集合所有的元素是以一种线性方式进行存储的，例如，存元素的顺序是11、22、33。那么集合中，元素的存储就是按照11、22、33的顺序完成的）
> - 它是一个元素存取有序的集合。即元素的存入顺序和取出顺序有保证。
> - 它是一个带有索引的集合，通过索引就可以精确的操作集合中的元素（与数组的索引是一个道理）。
> - 集合中可以有重复的元素，通过元素的equals方法，来比较是否为重复的元素。
>
> > List接口中的常用方法：(除去Collection中继承的方法)
> >
> > > `void add(int index,E ele)`
> > >
> > > boolean addAll(int index,Collection<? extends E> eles)
> >
> > > `E get(int index)`
> > >
> > > List subList(int fromIndex,int toIndex)
> >
> > > `int indexOf(Object obj)  `
> > >
> > > int lastIndexOf(Object obj)
> >
> > > `E remove(int index)`  //返回删除的元素
> > >
> > > `E set(int index,E ele)`  //指定位置index,进行元素替代
> >
> > List接口的实现类：**`ArrayList`**(动态数组)、`Vector`(动态数组-没有Fail-Fast机制)、`LinkedList`(双向链表,Node<T>)

***

###### Set集合

>+ Set接口是Collection的子接口，没有提供额外的方法，但是比Collection接口更严格
>+ Set集合不允许含有相同的元素，若添加相同的元素，则添加操作失败
>+ Set集合支持的遍历有两种：foreach 和 Iterator
>+ Set接口常用的实现类：HashSet、TreeSet、LinkedHashSet
>+ ![image-20220401110836190](http://ybll.vip/md-imgs/202204011108677.png)
>
>***
>
>HashSet  -->  new HashSet()  --> new HashMap<>();
>
>> + HashSet底层实现是HashMap,HashMap的底层实现是一个Hash表
>> + HashSet按照Hash算法来存储集合中的元素，有很好的存取和查找性能
>> + HashSet集合判断两个元素相等的标准：hashCode()相等，且equals()也相等，因此，存储到HashSet的对象，需要重写两方法
>>
>> ```java
>> class MyDate {
>>     private int year;
>>     private int month;
>>     private int day;
>> 
>>     public MyDate(int year, int month, int day) {
>>         this.year = year;
>>         this.month = month;
>>         this.day = day;
>>     }
>> 
>>     @Override
>>     public boolean equals(Object o) {
>>         if (this == o) return true;
>>         if (o == null || getClass() != o.getClass()) return false;
>>         MyDate myDate = (MyDate) o;
>>         return year == myDate.year &&
>>                 month == myDate.month &&
>>                 day == myDate.day;
>>     }
>> 
>>     @Override
>>     public int hashCode() {
>>         return Objects.hash(year, month, day);
>>     }
>> 
>>     @Override
>>     public String toString() {
>>         return "MyDate{" +
>>                 "year=" + year +
>>                 ", month=" + month +
>>                 ", day=" + day +
>>                 '}';
>>     }
>> }
>> ```
>>
>> ```java
>> public class TestHashSet {
>>     @Test
>>     public void test01(){
>>         HashSet<String> set = new HashSet<>();
>>         set.add("张三");
>>         set.add("张三");
>>         set.add("李四");
>>         set.add("王五");
>>         set.add("王五");
>>         set.add("赵六");
>> 		//添加重复元素不会报错，且输出无序，是按照hash排序
>>         System.out.println("set = " + set);//不允许重复，无序
>>     }
>> 
>>     @Test
>>     public void test02(){
>>         HashSet<MyDate> set = new HashSet<>();
>>         set.add(new MyDate(2021,1,1));
>>         set.add(new MyDate(2021,1,1));
>>         set.add(new MyDate(2022,2,4));
>>         set.add(new MyDate(2022,2,4));
>> 
>> 
>>         System.out.println("set = " + set);//不允许重复，无序
>>     }
>> }
>> ```
>
>LinkedHashSet
>
>> + LinkedHashSet是HashSet的子类，在结点中添加两个属性before和after维护结点的前后添加顺序
>> + 链表和哈希表组合的一个数据存储结构
>> + 插入性能略低于HashSet，但是迭代访问时又很好的性能
>>
>> ```java
>>  @Test
>>     public void test01(){
>>         LinkedHashSet<String> set = new LinkedHashSet<>();
>>         set.add("张三");
>>         set.add("张三");
>>         set.add("李四");
>>         set.add("王五");
>>         set.add("王五");
>>         set.add("赵六");
>> 		//添加重复元素不报错，且输出时按照添加的顺序依次输出
>>         System.out.println("set = " + set);//不允许重复，体现添加顺序
>>     }
>> ```
>
>TreeSet
>
>> + 维护了一个TreeMap,底层是基于红黑树实现的
>> + 不允许重复
>> + 实现排序：自然排序或者定制排序
>>   + 自然排序：让待添加的元素实现Comparable接口，并重写comparaTo()方法
>>   + 定制排序：创建Set对象时，指定Comparator比较器接口，并实现compare()方法
>>
>> ```java
>> @Test
>>     public void test01(){
>>         TreeSet<String> set = new TreeSet<>();
>>         set.add("张三");
>>         set.add("张三");
>>         set.add("张飞");
>>         set.add("李四");
>>         set.add("王五");
>>         set.add("王五");
>>         set.add("赵六");
>> 
>>         System.out.println("set = " + set);
>>         //不允许重复，体现大小顺序，String对象自然排序是依据Unicode编码值大小
>>         for (String s : set) {
>>             char[] chars = s.toCharArray();
>>             int[] codes = new int[chars.length];
>>             for (int i = 0; i < codes.length; i++) {
>>                 codes[i] = chars[i];
>>             }
>>             System.out.println(s + ":" + Arrays.toString(codes));
>>         }
>>     }
>> 
>>    @Test
>>     public void test05(){
>>         //Collator.getInstance(Locale.CHINA)是Comparator接口的实现类对象
>>         //String对象将按照字典顺序排列
>>         TreeSet<String> set = new TreeSet<>(Collator.getInstance(Locale.CHINA));
>> //        TreeSet<String> set = new TreeSet<>(new Comparator<String>() {
>> //            @Override
>> //            public int compare(String o1, String o2) {
>> //                return o1.length()-o2.length();
>> //            }
>> //        }); //使用此set，最终集合中只会有一个元素"张三",因为比较器返回0
>> 
>>         set.add("张三");
>>         set.add("张三");
>>         set.add("张飞");
>>         set.add("李四");
>>         set.add("王五");
>>         set.add("王五");
>>         set.add("赵六");
>> 
>>         System.out.println("set = " + set);
>>         //不允许重复，体现大小顺序
>>     }  //不允许重复，体现大小顺序
>>     }
>> ```

***

###### Collections工具类

> + 一个操作Set、List、Map等集合的工具类，对集合进行排序、查询、修改等操作，还提供了对集合对象设置不可变，对集合对象实现同步方法控制等
>
> > ```java
> > public static <T> boolean addAll(Collection<? super T> c,T...elements) //将elements元素都添加到c中
> > //在list中找某一个元素下标，当list的元素必须是T或者T的子类，且必须是可比较大小的，而且集合必须有序
> > public static <T> int binarySearch<List<? extends Comparable<? super T>> list, T key) 
> > ```
> >
> > - public static <T> boolean addAll(Collection<? super T> c,T... elements)将所有指定元素添加到指定 collection 中。
> > - public static <T> int binarySearch(List<? extends Comparable<? super T>> list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。
> > - public static <T> int binarySearch(List<? extends T> list,T key,Comparator<? super T> c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。
> > - public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序
> > - public static <T> T max(Collection<? extends T> coll,Comparator<? super T> comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者
> > - public static void reverse(List<?> list)反转指定列表List中元素的顺序。
> > - public static void shuffle(List<?> list) List 集合元素进行随机排序，类似洗牌
> > - public static <T extends Comparable<? super T>> void sort(List<T> list)根据元素的自然顺序对指定 List 集合元素按升序排序
> > - public static <T> void sort(List<T> list,Comparator<? super T> c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
> > - public static void swap(List<?> list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换
> > - public static int frequency(Collection<?> c,Object o)返回指定集合中指定元素的出现次数
> > - public static <T> void copy(List<? super T> dest,List<? extends T> src)将src中的内容复制到dest中
> > - public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值
> > - Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题
> > - Collections类中提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。

***

###### Map - java.util.Map<K,V>

> + Collection 中的集合称为单列集合，Map中的集合称作为双列合集
> + Map中不能有重复的键，值可以重复
> + Map不能用foreach和Iteator遍历，因为Map接口没有继承`java.lang.Iterator<T> ` 接口
>
> ![image-20220401111436574](http://ybll.vip/md-imgs/202204011114610.png)
>
> + 存储结构理解
>
>   ![image-20220401113153658](http://ybll.vip/md-imgs/202204011131721.png)
>
> Map常用方法
>
> > 添加操作
> >
> > V put(K key,V value) //返回替换前的值，替换前没有(key第一次添加)，则返回null
> >
> > void putAll(Map<? extends K,? extends V> m)
>
> > 删除操作
> >
> > void clear()
> >
> > V remove(Object key)
>
> > 元素查询的操作
> >
> > V get(Object key)
> >
> > boolean containsKey(Object key)
> >
> > boolean containsValue(Object value)
> >
> > boolean isEmpty()
>
> > 元视图操作的方法
> >
> > Set<K> keySet()
> >
> > Collection<V> values()
> >
> > Set<Map.Entry<K,V>> entrySet()
>
> > 其他方法
> >
> > int size()
>
> ```java
>  @Test
>     public void test01(){
>         //创建 map对象
>         HashMap<String, String> map = new HashMap<String, String>();
> 
>         //添加元素到集合
>         map.put("黄晓明", "杨颖");
>         map.put("文章", "马伊琍");
>         map.put("文章", "姚笛");
>         map.put("邓超", "孙俪");
>         System.out.println(map);
> 
>         //String remove(String key)
>         System.out.println(map.remove("黄晓明"));
>         System.out.println(map);
> 
>         // 想要查看 黄晓明的媳妇 是谁
>         System.out.println(map.get("黄晓明"));
>         System.out.println(map.get("邓超"));
>     }
> ```
>
> ***
>
> Map集合的遍历
>
> + 分开遍历：单独遍历所有key 或者单独遍历所以value
>
> + 成对遍历：遍历的对象是Map.Entry(映射关系的对象) --> 将Map.Entry放入Set<>集合中，进行遍历，Set<Map.Entry>
>
> + 每一种Map内部有自己的Map.Entry的实现类。在Map中存储数据，实际上是将Key---->value的数据存储在Map.Entry接口的实例中，再在Map集合中插入Map.Entry的实例化对象
>
>   ![image-20220401101620704](http://ybll.vip/md-imgs/202204011016489.png)
>
> ```java
>  @Test
>     public void test02(){
>         HashMap<String,String> map = new HashMap<>();
>         map.put("许仙", "白娘子");
>         map.put("董永", "七仙女");
>         map.put("牛郎", "织女");
>         map.put("许仙", "小青");
> 
>         System.out.println("所有的key:");
>         Set<String> keySet = map.keySet();
>         for (String key : keySet) {
>             System.out.println(key);
>         }
> 
>         System.out.println("所有的value：");
>         Collection<String> values = map.values();
>         for (String value : values) {
>             System.out.println(value);
>         }
> 
>         System.out.println("所有的映射关系");
>         Set<Map.Entry<String,String>> entrySet = map.entrySet();
>         for (Map.Entry<String,String> entry : entrySet) {
> //			System.out.println(entry);
>             System.out.println(entry.getKey()+"->"+entry.getValue());
>         }
>     }
> ```
>
> Map的实现类
>
> + `HashMap`、TreeMap、LinkedHashMap、Properties等
>
> > HashMap和Hashtable
> >
> > + 都是哈希表，判断两个key相等的标准是，两个key的hashCode相等，且equals()方法返回true,因此，作为键的对象必须实现hashCode()和equals()方法
> > + Hashtable是线程安全的，任何非null对象都可以作键或值
> > + HashMap是线程不安全的，允许使用null值和null键
> >
> > ```java
> > @Test
> >     public void test01(){
> >         HashMap<String,Double> map = new HashMap<>();
> >         map.put("张三", 10000.0);
> >         //key相同，新的value会覆盖原来的value
> >         //因为String重写了hashCode和equals方法
> >         map.put("张三", 12000.0);
> >         map.put("李四", 14000.0);
> >         //HashMap支持key和value为null值
> >         String name = null;
> >         Double salary = null;
> >         map.put(name, salary);
> > 
> >         Set<Map.Entry<String, Double>> entrySet = map.entrySet();
> >         for (Map.Entry<String, Double> entry : entrySet) {
> >             System.out.println(entry);
> >         }
> >     }
> > 
> >     @Test
> >     public void test02(){
> >         Hashtable<String,Double> map = new Hashtable<>();
> >         map.put("张三", 10000.0);
> >         //key相同，新的value会覆盖原来的value
> >         //因为String重写了hashCode和equals方法
> >         map.put("张三", 12000.0);
> >         map.put("李四", 14000.0);
> >         //Hashtable不支持key和value为null值
> >         /*String name = null;
> >         Double salary = null;
> >         map.put(name, salary);*/
> > 
> >         Set<Map.Entry<String, Double>> entrySet = map.entrySet();
> >         for (Map.Entry<String, Double> entry : entrySet) {
> >             System.out.println(entry);
> >         }
> >     }
> > ```
> >
> > ***
> >
> > LinkedHashMap -> HashMap的子类
> >
> > + 维护一个运行于所有元素的双重链接列表，此链接列表使得可以按照插入顺序进行迭代
> >
> > ```java
> > @Test
> > public void test01(){
> >     LinkedHashMap<String,Double> map = new LinkedHashMap<>();
> >         map.put("张三", 10000.0);
> >         //key相同，新的value会覆盖原来的value
> >         //因为String重写了hashCode和equals方法
> >         map.put("张三", 12000.0);
> >         map.put("李四", 14000.0);
> >         //HashMap支持key和value为null值
> >         String name = null;
> >         Double salary = null;
> >         map.put(name, salary);
> > 
> >         Set<Map.Entry<String, Double>> entrySet = map.entrySet();
> >         for (Map.Entry<String, Double> entry : entrySet) {
> >             System.out.println(entry);
> >         }
> > }
> > ```
> >
> > ***
> >
> > TreeMap  基于红黑树(Red-Black tree) 的 NavigableMap实现
> >
> > ```java
> > @Test
> > 	public void test1() {
> > 		TreeMap<String,Integer> map = new TreeMap<>();
> > 		map.put("Jack", 11000);
> > 		map.put("Alice", 12000);
> > 		map.put("zhangsan", 12000);
> > 		map.put("baitao", 14000);
> > 		map.put("Lucy", 15000);
> > 		
> > 		//String实现了Comparable接口，默认按照Unicode编码值排序
> > 		Set<Entry<String, Integer>> entrySet = map.entrySet();
> > 		for (Entry<String, Integer> entry : entrySet) {
> > 			System.out.println(entry);
> > 		}
> > 	}
> > 	@Test
> > 	public void test2() {
> > 		//指定定制比较器Comparator，按照Unicode编码值排序，但是忽略大小写
> > 		TreeMap<String,Integer> map = new TreeMap<>(new Comparator<String>() {
> > 
> > 			@Override
> > 			public int compare(String o1, String o2) {
> > 				return o1.compareToIgnoreCase(o2);
> > 			}
> > 		});
> > 		map.put("Jack", 11000);
> > 		map.put("Alice", 12000);
> > 		map.put("zhangsan", 12000);
> > 		map.put("baitao", 14000);
> > 		map.put("Lucy", 15000);
> > 		
> > 		Set<Entry<String, Integer>> entrySet = map.entrySet();
> > 		for (Entry<String, Integer> entry : entrySet) {
> > 			System.out.println(entry);
> > 		}
> > 	}
> > ```
>
> ***
>
> Set集合与Map集合的关系
>
> + Set的内部实现其实是一个Map。即HashSet的内部实现是一个HashMap，TreeSet的内部实现是一个TreeMap，LinkedHashSet的内部实现是一个LinkedHashMap。

***

###### HashMap底层实现

> **HashMap在jdk7中实现原理：**
> `HashMap map = new HashMap()`
>
> *      在实例化以后，底层创建了长度是16的一维数组Entry[] table。
> *      ...可能已经执行过多次put...
> *      map.put(key1,value1):
> *      首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置。
> *      如果此位置上的数据为空，此时的key1-value1添加成功。 ----情况1
> *      如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据的哈希值：
> *              如果key1的哈希值与已经存在的数据的哈希值都不相同，此时key1-value1添加成功。----情况2
> *              如果key1的哈希值和已经存在的某一个数据(key2-value2)的哈希值相同，继续比较：调用key1所在类的equals(key2)方法，比较：
> *                      如果equals()返回false:此时key1-value1添加成功。----情况3
> *                      如果equals()返回true:使用value1替换value2。
> *
> *      补充：关于情况2和情况3：此时key1-value1和原来的数据以链表的方式存储。
> *
> *     在不断的添加过程中，会涉及到扩容问题，当超出临界值(且要存放的位置非空)时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。

***

> **HashMap在jdk8中相较于jdk7在底层实现方面的不同：**
> 
> 1. new HashMap():底层没创建一个长度为16的数组
> 2. jdk 8底层的数组是：Node[],而非Entry[]
> 3. 首次调用put()方法时，底层创建长度为16的数组
> 4. jdk7底层结构只：数组+链表。jdk8中底层结构：数组+链表+红黑树。
>     4.1 形成链表时，七上八下（jdk7:新的元素指向旧的元素。jdk8：旧的元素指向新的元素）
>  4.2 当数组的某一个索引位置上的元素以链表形式存在的数据个数 > 8 且当前数组的长度 > 64时，此时此索引位置上的所数据改为使用红黑树存储。

***

> **HashMap底层典型属性的属性的说明：**
> DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16
> DEFAULT_LOAD_FACTOR：HashMap的默认加载因子：0.75
> threshold：扩容的临界值，=容量*填充因子：16 * 0.75 => 12
> TREEIFY_THRESHOLD：Bucket中链表长度大于该默认值，转化为红黑树:8
> MIN_TREEIFY_CAPACITY：桶中的Node被树化时最小的hash表容量:64

>  ![image-20220401113550340](http://ybll.vip/md-imgs/202204011135270.png)

> ![image-20220401114111269](http://ybll.vip/md-imgs/202204011141575.png)

> ![image-20220401114245566](http://ybll.vip/md-imgs/202204011142273.png)

***

###### 集合框架

![](http://ybll.vip/md-imgs/202204011229624.png)







##### 5. 泛型

###### 使用场合

>  泛型类、泛型接口、泛型方法
>
> + public class ArrayList<E>
>
> + public interface Map<K,V>
>
> + public static <T> List<T> asList(T...a){} //泛型方法中的泛型，写在返回值类型前，修饰符后(public static ...)
>
>   ```java
>       public static <T> void showS(T a){
>   //        T a = new T(); //写法错误，new后面只能写具体的类，表示创建具体类型的对象
>           return;
>       }
>   
>       public <T> T show(T a){
>           return a;
>       }
>   //以上都是泛型方法，可以是静态，也可以非静态
>   //注意：静态方法不能用类的泛型
>   ```
>
> 集合中使用泛型
>
> > ```java
> > //错误的指定
> > //Student<Object> stu = new Student<String>();//错误的
> > public class TestNumber {
> >     public static void main(String[] args) {
> >         Collection<Integer> coll = new ArrayList<Integer>();
> >         Random random = new Random();
> >         for (int i = 1; i <= 5 ; i++) {
> >             coll.add(random.nextInt(100));
> >         }
> > 
> >         System.out.println("coll中5个随机数是：");
> >         for (Integer integer : coll) {
> >             System.out.println(integer);
> >         }
> > 
> >         coll.removeIf(new Predicate<Integer>() {
> >             @Override
> >             public boolean test(Integer integer) {
> >                 return integer % 2 == 0;
> >             }
> >         });
> > 
> >         System.out.println("coll中删除偶数后：");
> >         Iterator<Integer> iterator = coll.iterator();
> >         while(iterator.hasNext()){
> >             Integer number = iterator.next();
> >             System.out.println(number);
> >         }
> > 
> >     }
> > }
> > ```
>
> ***
>
> Comparable接口使用泛型
>
> > ```java
> > public class Rectangle implements Comparable<Rectangle>{
> >     private double length;
> >     private double width;
> > 
> >     public Rectangle(double length, double width) {
> >         this.length = length;
> >         this.width = width;
> >     }
> >     public double area(){
> >         return length * width;
> >     }
> > 
> >     public double perimeter(){
> >         return 2 * (length + width);
> >     }
> >     @Override
> >     public int compareTo(Rectangle o) {
> >         int compare = Double.compare(area(), o.area());
> >         return compare != 0 ? compare : Double.compare(perimeter(),o.perimeter());
> >     }
> >     //get set toString...
> > }
> > 
> > @Test
> > public void test01(){
> >      Rectangle[] arr = new Rectangle[4];
> >         arr[0] = new Rectangle(6,2);
> >         arr[1] = new Rectangle(4,3);
> >         arr[2] = new Rectangle(13,1);
> >         arr[3] = new Rectangle(5,4);
> > 
> >         System.out.println("排序之前：");
> >         for (Rectangle rectangle : arr) {
> >             System.out.println(rectangle);
> >         }
> >         Arrays.sort(arr);
> >         System.out.println("排序之后：");
> >         for (Rectangle rectangle : arr) {
> >             System.out.println(rectangle);
> >         }
> > }
> > ```
>
> ***

###### 自定义泛型类和泛型接口

> > + 定义类或接口中某个成员类型不能确定，需要在使用类或接口时才能确定该成员类型，这可以使用泛型
> > + 如果定义了泛型类，实例化没指明类的泛型，则认为此泛型类型为Object类型
> > + 泛型不同的引用不能相互赋值(同类型不行，父子类关系也不行)
> >
> > 注意点：
> >
> > ![image-20220401141222461](http://ybll.vip/md-imgs/202204011412527.png)
> >
> > ![image-20220401141252053](http://ybll.vip/md-imgs/202204011412955.png)
>
> ***

###### 泛型擦除(难点)

> > 设置泛型上限  `<类型变量 extends 上限类型1 & 上限类型2>`
> >
> > + 上限类型中，有类有接口时，只能有一个类，且必须在最左边，接口可以有多个
> > + 没有指定extends上限时，默认上限是java.lang.Object
> >
> > 泛型擦除
> >
> > + 使用泛型类或者接口时没有指定泛型，则会发生泛型擦除，自动按照extends后第一个上限类型处理；没有指定上限类型时，上限为Object
> >
> > ```java
> > public class TestProblem {
> >     public static void m1(Collection<Object> coll){
> >         for (Object o : coll) {
> >             System.out.println(o);
> >         }
> >     }
> >     public static void m2(Collection coll){
> >         for (Object o : coll) {
> >             System.out.println(o);
> >         }
> >     }
> >     public static <T> void m3(Collection<T> coll){
> >         for (T o : coll) {
> >             System.out.println(o);
> >         }
> >     }
> >     
> >     public static void main(String[] args) {
> >         m1(new ArrayList<Object>());//Collection<Object> coll = new ArrayList<Object>();
> >         m1(new ArrayList<>());//Collection<Object> coll = new ArrayList<>();//与上面完全等价
> >         m1(new ArrayList());//Collection<Object> coll = new ArrayList();//有警告
> > //        m1(new ArrayList<String>());//Collection<Object> coll = new ArrayList<String>();//错误
> > 
> >         //编译看左边，左边泛型擦除，此处泛型按照Object处理，右边泛型指定啥都没用
> >         m2(new ArrayList<Object>());//Collection coll = new ArrayList<Object>();
> >         m2(new ArrayList<>());//Collection coll = new ArrayList<>();//与上面完全等价
> >         m2(new ArrayList());//Collection coll = new ArrayList();//泛型擦除
> >         m2(new ArrayList<String>());//Collection coll = new ArrayList<String>();
> > 
> >         m3(new ArrayList<Object>());//Collection<Object> coll = new ArrayList<Object>();
> >         m3(new ArrayList<>());//Collection<> coll = new ArrayList<>();//与上面完全等价
> >         m3(new ArrayList());//Collection<Object> coll = new ArrayList();//有警告
> >         m3(new ArrayList<String>());//Collection<String> coll = new ArrayList<String>();
> >     }
> > }
> > ```
>
> ***

###### 类型通配符（难点）

> > + 类A是类B的父类，G<A>和G<B>是没关系的，二者共同的父类是：G<?>
> >
> > 例如：Comparator<T>类型，如果我们仍然无法确定这个泛型类或泛型接口的类型变量<T>的具体类型，此时我们考虑使用类型通配符 `?` 
> >
> > ```java
> > public class TestWildcard {
> >     public static void m4(Collection<?> coll){
> >         for (Object o : coll) {
> >             System.out.println(o);
> >         }
> >     }
> > 
> >     public static void main(String[] args) {
> >         //右边泛型指定为任意类型或不指定都可以
> >         m4(new ArrayList<Object>());//Collection<?> coll = new ArrayList<Object>();
> >         m4(new ArrayList<>());//Collection<?> coll = new ArrayList<>();
> >         m4(new ArrayList());//Collection<?> coll = new ArrayList();
> >         m4(new ArrayList<String>());//Collection<?> coll = new ArrayList<String>();
> >     }
> > }
> > ```
> >
> > 通配符有三种形式
> >
> > + `<?>` : 此时 ? 表示任意类型
> >
> > + `<? extends 上限类型>`: ? 代表上限类型的子类或者上限类型本身
> >
> > + `<? super 下限类型>`: ? 代表下限类型的父类或者下限类型本身
> >
> > + 案例
> >
> >   ```java
> >   class MyCollections {
> >       public static boolean different(Collection<?> c1, Collection<?> c2){
> >           for (Object o : c1) {
> >               if(c2.contains(o)){
> >                   return false;
> >               }
> >           }
> >           return true;
> >       }
> >   
> >       public static <T> void addAll(Collection<? super T> c1, T... args){
> >           for (int i = 0; i < args.length; i++) {
> >               c1.add(args[i]);
> >           }
> >       }
> >   
> >       public static <T> void copy(Collection<? super T> dest,Collection<? extends T> src){
> >           for (T t : src) {
> >               dest.add(t);
> >           }
> >       }
> >   }
> >   
> >   public class MyCollectionsTest {
> >       public static void main(String[] args) {
> >           Collection<Integer> c1 = new ArrayList<Integer>();
> >           MyCollections.addAll(c1,1,2,3,4,5);
> >           System.out.println("c1 = " + c1);
> >   
> >           Collection<String> c2 = new ArrayList<String>();
> >           MyCollections.addAll(c2,"hello","java","world");
> >           System.out.println("c2 = " + c2);
> >   
> >           System.out.println("c1 != c2 " + MyCollections.different(c1, c2));
> >   
> >           Collection<Object> c3 = new ArrayList<>();
> >           MyCollections.copy(c3,c1);
> >           MyCollections.copy(c3,c2);
> >           System.out.println("c3 = " + c3);
> >       }
> >   }
> >   ```
> >
> > 使用类型通配符来指定类型参数的问题
> >
> > ```java
> > package com.atguigu.wildcard;
> > 
> > import java.util.ArrayList;
> > import java.util.Collection;
> > 
> > public class TestWildcardProblem {
> >     public static void main(String[] args) {
> >         Collection<?> c1 = new ArrayList<>();
> > //        c1.add(new Object());
> > //        c1.add("hello");
> > //        c1.add(1);
> >         //不能添加，c1只读
> > 
> > 
> >         Collection<? extends Object> c2 = new ArrayList<>();
> > //        c2.add(new Object());
> > //        c2.add("hello");
> > //        c2.add(1);
> >         //不能添加，c2只读
> > 
> >         Collection<? super Number> c3 = new ArrayList<>();
> > //        c3.add(new Object());
> > //        c3.add("hello");
> >         c3.add(1);
> >         //可以添加Number对象或Number子类对象
> >     }
> > }
> > ```

***

##### 6. 文件

###### `java.io.File类`

> 构造方法：
>
> + public File(String pathname)
> + public File(String parent,String child)
> + public File(File parent,String child)
>
> ```java
> public static void main(String[] args) {
>     // 文件路径名
>     String pathname = "D:\\aaa.txt";
>     File file1 = new File(pathname);
> 
>     // 文件路径名
>     String pathname2 = "D:\\aaa\\bbb.txt";
>     File file2 = new File(pathname2);
> 
>     // 通过父路径和子路径字符串
>     String parent = "d:\\aaa";
>     String child = "bbb.txt";
>     File file3 = new File(parent, child);
> 
>     // 通过父级File对象和子路径字符串
>     File parentDir = new File("d:\\aaa");
>     String childFile = "bbb.txt";
>     File file4 = new File(parentDir, childFile);
> }
> ```
>
> 小贴士：
>
> 1. 一个File对象代表硬盘或网络中可能存在的一个文件或者目录。
> 2. 无论该路径下是否存在文件或者目录，都不影响File对象的创建。
> 3. 如果File对象代表的文件或目录存在，则File对象实例初始化时，就会用硬盘中对应文件或目录的属性信息（例如，时间、类型等）为File对象的属性赋值，否则除了路径和名称，File对象的其他属性将会保留默认值
>
> ***
>
> 常用方法：
>
> * `public String getName()`  ：返回由此File表示的文件或目录的名称。  
> * `public long length()`  ：返回由此File表示的文件的长度。 目录则不指定
> * ` public String getPath() ` ：将此File转换为路径名字符串。 
> * `public long lastModified()`：返回File对象对应的文件或目录的最后修改时间（毫秒值）
>
> ```java
> public static void main(String[] args) {
>     File f = new File("d:/aaa/bbb.txt");
>     System.out.println("文件构造路径:"+f.getPath());
>     System.out.println("文件名称:"+f.getName());
>     System.out.println("文件长度:"+f.length()+"字节");
>     System.out.println("文件最后修改时间：" + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of("Asia/Shanghai")));
> 
>     File f2 = new File("d:/aaa");
>     System.out.println("目录构造路径:"+f2.getPath());
>     System.out.println("目录名称:"+f2.getName());
>     System.out.println("目录长度:"+f2.length()+"字节");
>     System.out.println("文件最后修改时间：" + LocalDateTime.ofInstant(Instant.ofEpochMilli(f.lastModified()),ZoneId.of("Asia/Shanghai")));
> }
> 
> /*
> 输出结果：
> 文件构造路径:d:\aaa\bbb.java
> 文件名称:bbb.java
> 文件长度:636字节
> 文件最后修改时间：2019-07-23T22:01:32.065
> 
> 目录构造路径:d:\aaa
> 目录名称:aaa
> 目录长度:4096字节
> */
> ```
>
> * ` public String getPath() ` ：将此File转换为路径名字符串。 
> * `public String getAbsolutePath() ` ：返回此File的绝对路径名字符串。
> * `String getCanonicalPath()`：返回此File对象所对应的规范路径名。
>
> ```java
> @Test
>     public void test1() throws IOException{
>         File f1 = new File("d:\\atguigu\\javase\\HelloIO.java"); //绝对路径
>         System.out.println("文件/目录的名称：" + f1.getName());
>         System.out.println("文件/目录的构造路径名：" + f1.getPath());
>         System.out.println("文件/目录的绝对路径名：" + f1.getAbsolutePath());
>         System.out.println("文件/目录的规范路径名：" + f1.getCanonicalPath());
>         System.out.println("文件/目录的父目录名：" + f1.getParent());
>     }
>     @Test
>     public void test02()throws IOException{
>         File f2 = new File("/HelloIO.java");//绝对路径，从根路径开始
>         System.out.println("文件/目录的名称：" + f2.getName());
>         System.out.println("文件/目录的构造路径名：" + f2.getPath());
>         System.out.println("文件/目录的绝对路径名：" + f2.getAbsolutePath());
>         System.out.println("文件/目录的规范路径名：" + f2.getCanonicalPath());
>         System.out.println("文件/目录的父目录名：" + f2.getParent());
>     }
> 
>     @Test
>     public void test03() throws IOException {
>         File f3 = new File("HelloIO.java");//相对路径
>         System.out.println("user.dir =" + System.getProperty("user.dir"));
>         System.out.println("文件/目录的名称：" + f3.getName());
>         System.out.println("文件/目录的构造路径名：" + f3.getPath());
>         System.out.println("文件/目录的绝对路径名：" + f3.getAbsolutePath());
>         System.out.println("文件/目录的规范路径名：" + f3.getCanonicalPath());
>         System.out.println("文件/目录的父目录名：" + f3.getParent());
>     }
>     @Test
>     public void test04() throws IOException{
>         File f4 = new File("../../HelloIO.java");//相对路径
>         System.out.println("user.dir =" + System.getProperty("user.dir"));
>         System.out.println("文件/目录的名称：" + f4.getName());
>         System.out.println("文件/目录的构造路径名：" + f4.getPath());
>         System.out.println("文件/目录的绝对路径名：" + f4.getAbsolutePath());
>         System.out.println("文件/目录的规范路径名：" + f4.getCanonicalPath());
>         System.out.println("文件/目录的父目录名：" + f4.getParent());
>     }
> 
>     public static void main(String[] args)throws IOException {
>         File f5 = new File("HelloIO.java");//相对路径
>         System.out.println("user.dir =" + System.getProperty("user.dir"));
>         System.out.println("文件/目录的名称：" + f5.getName());
>         System.out.println("文件/目录的构造路径名：" + f5.getPath());
>         System.out.println("文件/目录的绝对路径名：" + f5.getAbsolutePath());
>         System.out.println("文件/目录的规范路径名：" + f5.getCanonicalPath());
>         System.out.println("文件/目录的父目录名：" + f5.getParent());
>     }
> ```
>
> - `public boolean exists()` ：此File表示的文件或目录是否实际存在。
> - `public boolean isDirectory()` ：此File表示的是否为目录。
> - `public boolean isFile()` ：此File表示的是否为文件。
>
> - `public boolean createNewFile()` ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。 
> - `public boolean delete()` ：删除由此File表示的文件或目录。  只能删除空目录。
> - `public boolean mkdir()` ：创建由此File表示的目录。
> - `public boolean mkdirs()` ：创建由此File表示的目录，包括任何必需但不存在的父目录。
>
> * `public String[] list()` ：返回一个String数组，表示该File目录中的所有子文件或目录。
>
>
> * `public File[] listFiles()` ：返回一个File数组，表示该File目录中的所有的子文件或目录。  

***

###### IO流

> 根据数据的流向分为：**输入流**和**输出流**。
>
> - **输入流** ：把数据从`其他设备`上读取到`内存`中的流。 
>   - 以InputStream,Reader结尾
> - **输出流** ：把数据从`内存` 中写出到`其他设备`上的流。
>   - 以OutputStream、Writer结尾
>
> 根据数据的类型分为：**字节流**和**字符流**。
>
> - **字节流** ：以字节为单位，读写数据的流。
>   - 以InputStream和OutputStream结尾
> - **字符流** ：以字符为单位，读写数据的流。
>   - 以Reader和Writer结尾
>
> 根据IO流的角色不同分为：**节点流**和**处理流**。
>
> * **节点流**：可以从或向一个特定的地方（节点）读写数据。如FileReader.
>
> * **处理流**：是对一个已存在的流进行连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。
>
>   > 这种设计是装饰模式（Decorator Pattern）也称为包装模式（Wrapper Pattern），其使用一种对客户端透明的方式来动态地扩展对象的功能，它是通过继承扩展功能的替代方案之一。在现实生活中你也有很多装饰者的例子，例如：人需要各种各样的衣着，不管你穿着怎样，但是，对于你个人本质来说是不变的，充其量只是在外面加上了一些装饰，有，“遮羞的”、“保暖的”、“好看的”、“防雨的”....
>
> **常用的节点流：** 　
>
> - 文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。
> - 字符串 StringReader StringWriter 对字符串进行处理的节点流。
> - 数 组 ByteArrayInputStream ByteArrayOutputStream CharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。
> - 管 道 PipedInputStream、PipedOutputStream、PipedReader、PipedWriter对管道进行处理的节点流。
>
> **常用处理流：**
>
> - 缓冲流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter---增加缓冲功能，避免频繁读写硬盘。
> - 转换流：InputStreamReader、OutputStreamReader---实现字节流和字符流之间的转换。
> - 数据流：DataInputStream、DataOutputStream -提供读写Java基础数据类型功能
> - 对象流：ObjectInputStream、ObjectOutputStream--提供直接读写Java对象功能
>
> ***
>
> 4个抽象父类：
>
> |            |        **输入流**         |           输出流           |
> | :--------: | :-----------------------: | :------------------------: |
> | **字节流** | 字节输入流**InputStream** | 字节输出流**OutputStream** |
> | **字符流** |   字符输入流**Reader**    |    字符输出流**Writer**    |
>
> > `java.io.OutputStream `抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。它定义了字节输出流的基本共性功能方法。
> >
> > - `public void write(int b)` ：将指定的字节输出流。虽然参数为int类型四个字节，但是只会保留一个字节的信息写出。
> > - `public void write(byte[] b)`：将 b.length字节从指定的字节数组写入此输出流。  
> > - `public void write(byte[] b, int off, int len)` ：从指定的字节数组写入 len字节，从偏移量 off开始输出到此输出流。  
> > - `public void flush() ` ：刷新此输出流并强制任何缓冲的输出字节被写出。  
> > - `public void close()` ：关闭此输出流并释放与此流相关联的任何系统资源。  
> >
> > > 小贴士：close方法，当完成流的操作时，必须调用此方法，释放系统资源。
> >
> > ```java
> > public static void main(String[] args) throws IOException {
> >     // 使用文件名称创建流对象
> >     FileOutputStream fos = new FileOutputStream("fos.txt");
> >     // 定义字节数组
> >     byte[] words = {97,98,99,100,101};
> >     // 遍历数组
> >     for (int i = 0; i < words.length; i++) {
> >         // 写出一个字节
> >         fos.write(words[i]);
> >         // 写出一个换行, 换行符号转成数组写出
> >         fos.write("\r\n".getBytes());
> >     }
> >     // 关闭资源
> >     fos.close();
> > }
> > ```
> >
> > - 回车符`\r`和换行符`\n` ：
> >   - 回车符：回到一行的开头（return）。
> >   - 换行符：下一行（newline）。
> > - 系统中的换行：
> >   - Windows系统里，每行结尾是 `回车+换行` ，即`\r\n`；
> >   - Unix系统里，每行结尾只有 `换行` ，即`\n`；
> >   - Mac系统里，每行结尾是 `回车` ，即`\r`。从 Mac OS X开始与Linux统一。
>
> ***
>
> > `java.io.InputStream `抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。它定义了字节输入流的基本共性功能方法。
> >
> > - `public int read()`： 从输入流读取一个字节。返回读取的字节值。虽然读取了一个字节，但是会自动提升为int类型。如果已经到达流末尾，没有数据可读，则返回-1。 
> > - `public int read(byte[] b)`： 从输入流中读取一些字节数，并将它们存储到字节数组 b中 。每次最多读取b.length个字节。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 
> > - `public int read(byte[] b,int off,int len)`：从输入流中读取一些字节数，并将它们存储到字节数组 b中，从b[off]开始存储，每次最多读取len个字节 。返回实际读取的字节个数。如果已经到达流末尾，没有数据可读，则返回-1。 
> > - `public void close()` ：关闭此输入流并释放与此流相关联的任何系统资源。 
>
> ***
>
> 字节输入、输出流：`FileInputStream` / `FileOutputStream`
>
> ```java
> public static void main(String[] args) throws IOException {
>         // 1.创建流对象
>         // 1.1 指定数据源
>         FileInputStream fis = new FileInputStream("D:\\test.jpg");
>         // 1.2 指定目的地
>         FileOutputStream fos = new FileOutputStream("test_copy.jpg");
> 
>         // 2.读写数据
>         // 2.1 定义数组
>         byte[] b = new byte[1024];
>         // 2.2 定义长度
>         int len;
>         // 2.3 循环读取
>         while ((len = fis.read(b))!=-1) {
>             // 2.4 写出数据
>             fos.write(b, 0 , len);
>         }
> 
>         // 3.关闭资源
>         fos.close();
>         fis.close();
>     }
> }
> ```
>
> ***
>
> > 字符输入、输出流：
> >
> > FileWriter与FileOutputStream不同。因为内置缓冲区的原因，如果不关闭输出流，无法写出字符到文件中。但是关闭的流对象，是无法继续写出数据的。如果我们既想写出数据，又想继续使用流，就需要`flush` 方法了。
> >
> > - `flush` ：刷新缓冲区，流对象可以继续使用。
> > - `close `:先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。
> >
> > 代码使用演示：
> >
> > ```java
> > package com.atguigu.fileio;
> > 
> > import java.io.FileWriter;
> > import java.io.IOException;
> > 
> > public class FWWriteFlush {
> >     public static void main(String[] args)throws IOException {
> >         // 使用文件名称创建流对象
> >         FileWriter fw = new FileWriter("fw.txt");
> >         // 写出数据，通过flush
> >         fw.write('刷'); // 写出第1个字符
> >         fw.flush();
> >         fw.write('新'); // 继续写出第2个字符，写出成功
> >         fw.flush();
> > 
> >         // 写出数据，通过close
> >         fw.write('关'); // 写出第1个字符
> >         fw.close();
> >         fw.write('闭'); // 继续写出第2个字符,【报错】java.io.IOException: Stream closed
> >         fw.close();
> >     }
> > }
> > ```
> >
> > > 小贴士：即便是flush方法写出了数据，操作的最后还是要调用close方法，释放系统资源。
>
> ***
>
> > 缓冲流
> >
> > > 缓冲流,也叫高效流，按照数据类型分类：
> > >
> > > * **字节缓冲流**：`BufferedInputStream`，`BufferedOutputStream` 
> > > * **字符缓冲流**：`BufferedReader`，`BufferedWriter`
> > >
> > > 缓冲流的基本原理，是在创建流对象时，会创建一个内置的默认大小的缓冲区数组，通过缓冲区读写，减少系统IO次数，从而提高读写的效率。
> >
> > ***
> >
> > > 字符缓冲流的基本方法与普通字符流调用方式一致，不再阐述，我们来看它们具备的特有方法。
> > >
> > > * BufferedReader：`public String readLine()`: 读一行文字。 
> > > * BufferedWriter：`public void newLine()`: 写一行行分隔符,由系统属性定义符号。 
>
> ***
>
> > 转换流
> >
> > > 转换流`java.io.InputStreamReader`，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。 
> > >
> > > * `InputStreamReader(InputStream in)`: 创建一个使用默认字符集的字符流。 
> > > * `InputStreamReader(InputStream in, String charsetName)`: 创建一个指定字符集的字符流。
> >
> > ***
> >
> > > 转换流`java.io.OutputStreamWriter` ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。 
> > >
> > > - `OutputStreamWriter(OutputStream in)`: 创建一个使用默认字符集的字符流。 
> > > - `OutputStreamWriter(OutputStream in, String charsetName)`: 创建一个指定字符集的字符流。
> >
> > ***
>
> ***
>
> 数据流与对象流
>
> - DataOutputStream：数据输出流允许应用程序以适当方式将基本 Java 数据类型写入输出流中。然后，应用程序可以使用数据输入流（DataInputStream）将数据读入。 
> - DataInputStream：数据输入流允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。
> - ObjectOutputStream：将 Java 基本数据类型和对象写入字节输出流中。稍后可以使用 ObjectInputStream 将数据读入。通过在流中使用文件可以实现Java各种基本数据类型的数据以及对象的持久存储。如果流是网络套接字流，则可以在另一台主机上或另一个进程中接收这些数据或重构对象。 
> - ObjectInputStream：ObjectInputStream 对以前使用 ObjectOutputStream 写入的基本数据和对象进行反序列化。 

***

##### 7. 网络编程

> 如果说**IP地址**可以唯一标识网络中的设备，那么**端口号**就可以唯一标识设备中的进程（应用程序）了。
>
> 端口号：两个字节表示，取值范围：0-65536
>
> + 公认端口：0-1023；如：HTTP(80) / FTP(21)/Telnet(23)
> + 注册端口：1024-49151 ；分配给用户进程或应用程序；如：Tomcat(8080)/MySQL(3306)/Oracle(1521)
> + 动态/私有端口：49152-65535

***

##### 8. 反射